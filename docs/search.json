[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "andrejmuhic.github.io",
    "section": "",
    "text": "Formula that generates all primes\n\n\n\n\n\n\nAlgebra\n\n\nNumber Theory\n\n\n\n\n\n\n\n\n\nMay 30, 2024\n\n\nAndrej Muhic\n\n\n\n\n\n\n\n\n\n\n\n\nGPT and more from scratch with comments\n\n\n\n\n\n\nNLP\n\n\ntransformers\n\n\ndeep learning\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nMay 28, 2024\n\n\nAndrej Muhic\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nMay 28, 2024\n\n\nAndrej Muhic\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in my Quarto blog. Welcome! I will mainly post about the topics I like playing with. Sometimes I will use this blog to motivate the cleaner exposition of the problems by writing about them. I find sometimes the best way of checking the understanding is trying to explain it to others."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html",
    "title": "GPT and more from scratch with comments",
    "section": "",
    "text": "All original credits to companion notebook to the Zero To Hero video on GPT by Andrej Karpathy. Code was modified and heavily commented."
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#transformer-architecture",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#transformer-architecture",
    "title": "GPT and more from scratch with comments",
    "section": "Transformer architecture",
    "text": "Transformer architecture\nThis blog post is meant as a collection of resources to facilitate deeper and easier understanding of the transformer architecture and also the main deep learning concepts. Let us start with the graph of multi head causal transformer with learnable positional embedding with the following setup in the full blown annotated image of the multi head attention with learnable positional encoding:\n# hyperparameters\nbatch_size = 1024 # how many independent sequences will we process in parallel?\nblock_size = 128 # what is the maximum context length for predictions?\nn_embd = 64\nn_head = 2\nn_layer = 2\nmax_iters = 10000\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\neval_iters = 200\n\n\nCreating a graph of the model\n\nfrom torchview import draw_graph\nimport torchlens as tl\nfrom pathlib import Path\n\n#device='meta' -&gt; no memory is consumed for visualization\nmodel = GPT2LanguageModel()\nm = model.to(device)\n#the number of parameters in the model\nprint(sum(p.numel() for p in m.parameters()) / 1e6, 'M parameters')\n\nxb, yb = get_batch('train')\nprint(xb.shape)\nprint(yb.shape)\nmodel_graph = draw_graph(model, input_data=(xb, yb), depth=5, expand_nested=True, save_graph=False,\n                         directory=str(Path('~').expanduser()), device='cuda')\nprint(model_graph)\ngraph = model_graph.visual_graph\nformat='svg'\ngraph_svg = graph.pipe(format='svg').decode('utf-8') # convert to binary data\nfile = str(Path('~').expanduser()) + '/multihead_transformer_with_learnable_positional_encoding.' + format\nprint(file)\nwith open(file, 'wt') as f:\n    f.write(graph_svg)\n\n\n\n\nMultihead transformer with learnable positional encoding\n\n\nIf you can reason about the model only looking at the picture then you can skip most of the details and just dive in. The code tries to be well documented with plenty of the links to the resources that help to look at things from different perspective. If you are beginner in deep learning but have solid mathematical background I also provide collection of resources that can be helpful to get up to the speed quickly. I was using this mainly as scratchpad to note my ideas and questions over years. The view that I liked the most is transformers as GNN with additional positional encoding as I got attracted by nice symmetry, group and even categorical abstract motivation of the deep learning in general. I would like to also to point to extrakt.AI for one nice use case of information extraction and specifically Jan Rupnik and AiLab@JSI for several stimulating discussions. I also recommend checking Soniox for interesting applications in the deeper understanding of the audio."
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#cleaned-up-code-resources",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#cleaned-up-code-resources",
    "title": "GPT and more from scratch with comments",
    "section": "Cleaned up code resources",
    "text": "Cleaned up code resources\nFor cleaned up code see Karpathy:\n\nminGPT for python Pytorch version.\nnanoGPT\nllm.c for pure C implementation.\nllama2.c for llama inference in C.\nllama.cpp to have some fun locally.\nhttps://huggingface.co/docs/transformers/en/"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#key-techiques-so-deep-learning-is-easier-to-use",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#key-techiques-so-deep-learning-is-easier-to-use",
    "title": "GPT and more from scratch with comments",
    "section": "Key techiques so deep learning is easier to use",
    "text": "Key techiques so deep learning is easier to use\n\nAdam/AdamW optimizer\nTransformers\nResidual connections\nDropout\nLayer/batch normalization\nAutomatic differentiation improvements\nPolished libraries that are easy to use, PyTorch\nHardware acceleration optimized for the architectures"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#strict-run-time-named-dimension-checking",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#strict-run-time-named-dimension-checking",
    "title": "GPT and more from scratch with comments",
    "section": "Strict run time named dimension checking",
    "text": "Strict run time named dimension checking\n\nhttps://kidger.site/thoughts/jaxtyping/\nhttps://docs.kidger.site/jaxtyping/api/array/\nhttps://github.com/patrick-kidger/jaxtyping\nhttps://github.com/agronholm/typeguard"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#tracking-progress-of-your-runs",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#tracking-progress-of-your-runs",
    "title": "GPT and more from scratch with comments",
    "section": "Tracking progress of your runs",
    "text": "Tracking progress of your runs\n\nhttps://github.com/aimhubio/aim free\nhttps://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html free\nhttps://wandb.ai/site paid"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#optimization-adamw-state-of-the-art",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#optimization-adamw-state-of-the-art",
    "title": "GPT and more from scratch with comments",
    "section": "Optimization, AdamW state of the art",
    "text": "Optimization, AdamW state of the art\n\nhttps://www.ruder.io/optimizing-gradient-descent/#adam\nhttps://iclr-blogposts.github.io/2023/blog/2023/adamw as proximal operator\nhttps://arxiv.org/abs/2404.04454 Implicit Bias of AdamW: ℓ∞ Norm Constrained Optimization optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate) Adam is just using exponential weighted average of gradient and “variance of gradients”, corrected for bias for starting at 0. AdamW adds a trick to do better incorporate L2 regularization for weight decay and is best viewed as proximal operator in my opinion.\n\n\nTroubles with regular techniques\n\nMemory constraints even for Adam(W) we need to store two additional vectors thus we 3x our memory requirements.\nBack stepping is not feasible for deep learning, too costly to store harder to parallelize!\nhttps://en.wikipedia.org/wiki/Limited-memory_BFGS approximates inverse of Hessian implicitly and even this is too costly.\nhttps://en.wikipedia.org/wiki/Wolfe_conditions\nhttps://en.wikipedia.org/wiki/Backtracking_line_search more advanced step size"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#visualizing-the-network",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#visualizing-the-network",
    "title": "GPT and more from scratch with comments",
    "section": "Visualizing the network",
    "text": "Visualizing the network\n\nMy personal favourite: https://github.com/mert-kurttutan/torchview nicer graph, device=‘meta’ is buggy sometimes, use cuda or cpu.\nHonourable mentions: https://github.com/szagoruyko/pytorchviz"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#activations",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#activations",
    "title": "GPT and more from scratch with comments",
    "section": "Activations",
    "text": "Activations\n\nhttps://www.ai-contentlab.com/2023/03/swishglu-activation-function.html\nhttps://pytorch.org/docs/stable/generated/torch.nn.SiLU.html"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#useful-tricks",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#useful-tricks",
    "title": "GPT and more from scratch with comments",
    "section": "Useful tricks",
    "text": "Useful tricks\n\nEinsum formulas for humans\n\nhttps://einops.rocks/api/einsum\n\n\n\nBroadcasting\n\nhttps://numpy.org/doc/stable/user/basics.broadcasting.html My advice would be if you are not sure do manual broadcasting and test.\nStrictly test dimenstions with something like jaxtyping\n\n\n\nSanity checks and data\n\nInspect your data before you start training\nOverift on small piece of data using simplest possible model before trying to do something fancy\nGetting better and more data will bring larger improvements than using superior model"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#nlp-specific-info",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#nlp-specific-info",
    "title": "GPT and more from scratch with comments",
    "section": "NLP specific info",
    "text": "NLP specific info\n\nTokenization\n\nIn practice one would use something like Byte Pair Encoding or WordPiece, SentencePiece ### Attention and geometric deep learning\nAttention: https://magazine.sebastianraschka.com/p/understanding-and-coding-self-attention\nGNN and Geometric Deep Learning\nGeometric Deep learning excites me as mathematician as it is a very nice way of infusing domain priors, symmetry, geometry of the problem\n\n\n\nAlternative architectures and improvements\n\nMamba\nMamba with more details\nFlash attention, hardware optimized attention\n\n\n\nEmbeddings\n\nClassical not relative but fixed embedding\nRoPE - Rotary Positional Embedding\nRotary embeddings\n\n\n\nVarious sources\n\nHow to influence bias of probabilities, temperature using LogSumExp What happens when you divide logits by positivee \\(\\texttt{Temp}\\) and then do \\(\\texttt{softmax}.\\) Temperature close to 0 gives us max in limit, one hot, \\(\\texttt{Temp}\\) &gt;&gt; 1 in limit is random sampling.\nUnderstanding llama2\nForward and reverse KL divergence"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#stricter-typing",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#stricter-typing",
    "title": "GPT and more from scratch with comments",
    "section": "Stricter typing",
    "text": "Stricter typing\n\n\nCode\n# Let us do some stricter typing\n%config Completer.use_jedi = False\n# from sklearn.model_selection import train_test_split\nimport typing\nfrom typing import TYPE_CHECKING, Any, Optional\nimport torch\n\n# Strict run time dimension checking\n# https://kidger.site/thoughts/jaxtyping/\n# https://docs.kidger.site/jaxtyping/api/array/\n# https://github.com/patrick-kidger/jaxtyping\n# https://github.com/agronholm/typeguard\n\n# Tracking the progress: \n#                        https://github.com/aimhubio/aim\n#                        https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html\n#                        https://wandb.ai/site\n\n# Something on order of distributions in cross entropy and KL\n# https://agustinus.kristia.de/techblog/2016/12/21/forward-reverse-kl/\n\n# Visualizing the network\n# https://github.com/szagoruyko/pytorchviz\n# https://github.com/mert-kurttutan/torchview nicer graph\n\n# Optimization, AdamW state of the art\n# https://www.ruder.io/optimizing-gradient-descent/#adam\n# https://iclr-blogposts.github.io/2023/blog/2023/adamw/ as proximal operator\n# https://arxiv.org/abs/2404.04454 Implicit Bias of AdamW: ℓ∞ Norm Constrained Optimization\n# optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)\n# exponential weighted average of gradient and \"variance of gradients\", corrected for bias for starting at 0 \n# +  a trick to do better than L2 for decay rate\n# Back stepping\n# Not feasible for deep learning, too costly to store harder to parallelize!\n# https://en.wikipedia.org/wiki/Limited-memory_BFGS approximates inverse of Hessian implicitly and even this is too costly\n# https://en.wikipedia.org/wiki/Wolfe_conditions\n# https://en.wikipedia.org/wiki/Backtracking_line_search more advanced step size\n\n# Activations\n# https://www.ai-contentlab.com/2023/03/swishglu-activation-function.html\n# https://pytorch.org/docs/stable/generated/torch.nn.SiLU.html\n\n# Einsum formulas for human, thanks for the hint guys!\n# https://einops.rocks/api/einsum/\n\n# Broadcasting\n# https://numpy.org/doc/stable/user/basics.broadcasting.html My advice would be if you are not sure do manual broadcasting and test.\n# Strictly test dimenstions with something like jaxtyping\n\n# key enabling techiques that made deep learning more easy to work with\n# - adam/adamw optimizer\n# - residual connections\n# - dropout\n# - layer/batch normalization\n# - automatic differentiation\n\nfrom jaxtyping import Float, Int64\n\nArray: typing.TypeAlias = torch.Tensor\nLong: typing.TypeAlias = Int64"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#loading-the-data",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#loading-the-data",
    "title": "GPT and more from scratch with comments",
    "section": "Loading the data",
    "text": "Loading the data\n\n\nCode\n# We always start with a dataset to train on. Let's download the tiny shakespeare dataset\nfrom pathlib import Path\nsave_path = Path('~').expanduser() / f'.cache/input.txt'\nif not save_path.exists():\n    !wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt -O {save_path}"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#inspecting-the-data",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#inspecting-the-data",
    "title": "GPT and more from scratch with comments",
    "section": "Inspecting the data",
    "text": "Inspecting the data\n\n\nCode\n# read it in to inspect it\nwith save_path.open('r', encoding='utf-8') as f:\n    text = f.read()\n\n\n\n\nCode\nprint(\"length of dataset in characters: \", len(text))\n\n\nlength of dataset in characters:  1115394\n\n\n\n\nCode\n# let's look at the first 1000 characters\nprint(text[:1000])\n\n\nFirst Citizen:\nBefore we proceed any further, hear me speak.\n\nAll:\nSpeak, speak.\n\nFirst Citizen:\nYou are all resolved rather to die than to famish?\n\nAll:\nResolved. resolved.\n\nFirst Citizen:\nFirst, you know Caius Marcius is chief enemy to the people.\n\nAll:\nWe know't, we know't.\n\nFirst Citizen:\nLet us kill him, and we'll have corn at our own price.\nIs't a verdict?\n\nAll:\nNo more talking on't; let it be done: away, away!\n\nSecond Citizen:\nOne word, good citizens.\n\nFirst Citizen:\nWe are accounted poor citizens, the patricians good.\nWhat authority surfeits on would relieve us: if they\nwould yield us but the superfluity, while it were\nwholesome, we might guess they relieved us humanely;\nbut they think we are too dear: the leanness that\nafflicts us, the object of our misery, is as an\ninventory to particularise their abundance; our\nsufferance is a gain to them Let us revenge this with\nour pikes, ere we become rakes: for the gods know I\nspeak this in hunger for bread, not in thirst for revenge.\n\n\n\n\n\nUnique characters as tokens, 65 vocabulary size\n\n\nCode\n# here are all the unique characters that occur in this text\nchars: list[str] = sorted(list(set(text)))\nvocab_size = len(chars)\nprint(''.join(chars))\nprint(vocab_size)\n\n\n\n !$&',-.3:;?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n65\n\n\n\n\nMapping from characters to integers\n\n\nCode\n# create a mapping from characters to integers\nstoi: dict[str, int] = {ch: i for i, ch in enumerate(chars)}\nitos: dict[int, str] = {i: ch for i, ch in enumerate(chars)}\nencode = lambda s: [stoi[c] for c in s]  # encoder: take a string, output a list of integers\ndecode = lambda l: ''.join([itos[i] for i in l])  # decoder: take a list of integers, output a string\n\n# In practice one would use something like [Byte Pair Encoding](https://github.com/karpathy/minbpe) or [WordPiece, SentencePiece](https://huggingface.co/docs/transformers/en/tokenizer_summary)\n\nprint(encode(\"hii there\"))\nprint(decode(encode(\"hii there\")))\n\n\n[46, 47, 47, 1, 58, 46, 43, 56, 43]\nhii there\n\n\n\n\nCode\n# let's now encode the entire text dataset and store it into a torch.Tensor\nimport torch  # we use PyTorch: https://pytorch.org\n\ndata = torch.tensor(encode(text), dtype=torch.int64)\nprint(data.shape, data.dtype)\nprint(data[:1000])  # the 1000 characters we looked at earier will to the GPT look like this\n\n\ntorch.Size([1115394]) torch.int64\ntensor([18, 47, 56, 57, 58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 14, 43, 44,\n        53, 56, 43,  1, 61, 43,  1, 54, 56, 53, 41, 43, 43, 42,  1, 39, 52, 63,\n         1, 44, 59, 56, 58, 46, 43, 56,  6,  1, 46, 43, 39, 56,  1, 51, 43,  1,\n        57, 54, 43, 39, 49,  8,  0,  0, 13, 50, 50, 10,  0, 31, 54, 43, 39, 49,\n         6,  1, 57, 54, 43, 39, 49,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47,\n        58, 47, 64, 43, 52, 10,  0, 37, 53, 59,  1, 39, 56, 43,  1, 39, 50, 50,\n         1, 56, 43, 57, 53, 50, 60, 43, 42,  1, 56, 39, 58, 46, 43, 56,  1, 58,\n        53,  1, 42, 47, 43,  1, 58, 46, 39, 52,  1, 58, 53,  1, 44, 39, 51, 47,\n        57, 46, 12,  0,  0, 13, 50, 50, 10,  0, 30, 43, 57, 53, 50, 60, 43, 42,\n         8,  1, 56, 43, 57, 53, 50, 60, 43, 42,  8,  0,  0, 18, 47, 56, 57, 58,\n         1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 18, 47, 56, 57, 58,  6,  1, 63,\n        53, 59,  1, 49, 52, 53, 61,  1, 15, 39, 47, 59, 57,  1, 25, 39, 56, 41,\n        47, 59, 57,  1, 47, 57,  1, 41, 46, 47, 43, 44,  1, 43, 52, 43, 51, 63,\n         1, 58, 53,  1, 58, 46, 43,  1, 54, 43, 53, 54, 50, 43,  8,  0,  0, 13,\n        50, 50, 10,  0, 35, 43,  1, 49, 52, 53, 61,  5, 58,  6,  1, 61, 43,  1,\n        49, 52, 53, 61,  5, 58,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47, 58,\n        47, 64, 43, 52, 10,  0, 24, 43, 58,  1, 59, 57,  1, 49, 47, 50, 50,  1,\n        46, 47, 51,  6,  1, 39, 52, 42,  1, 61, 43,  5, 50, 50,  1, 46, 39, 60,\n        43,  1, 41, 53, 56, 52,  1, 39, 58,  1, 53, 59, 56,  1, 53, 61, 52,  1,\n        54, 56, 47, 41, 43,  8,  0, 21, 57,  5, 58,  1, 39,  1, 60, 43, 56, 42,\n        47, 41, 58, 12,  0,  0, 13, 50, 50, 10,  0, 26, 53,  1, 51, 53, 56, 43,\n         1, 58, 39, 50, 49, 47, 52, 45,  1, 53, 52,  5, 58, 11,  1, 50, 43, 58,\n         1, 47, 58,  1, 40, 43,  1, 42, 53, 52, 43, 10,  1, 39, 61, 39, 63,  6,\n         1, 39, 61, 39, 63,  2,  0,  0, 31, 43, 41, 53, 52, 42,  1, 15, 47, 58,\n        47, 64, 43, 52, 10,  0, 27, 52, 43,  1, 61, 53, 56, 42,  6,  1, 45, 53,\n        53, 42,  1, 41, 47, 58, 47, 64, 43, 52, 57,  8,  0,  0, 18, 47, 56, 57,\n        58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 35, 43,  1, 39, 56, 43,  1,\n        39, 41, 41, 53, 59, 52, 58, 43, 42,  1, 54, 53, 53, 56,  1, 41, 47, 58,\n        47, 64, 43, 52, 57,  6,  1, 58, 46, 43,  1, 54, 39, 58, 56, 47, 41, 47,\n        39, 52, 57,  1, 45, 53, 53, 42,  8,  0, 35, 46, 39, 58,  1, 39, 59, 58,\n        46, 53, 56, 47, 58, 63,  1, 57, 59, 56, 44, 43, 47, 58, 57,  1, 53, 52,\n         1, 61, 53, 59, 50, 42,  1, 56, 43, 50, 47, 43, 60, 43,  1, 59, 57, 10,\n         1, 47, 44,  1, 58, 46, 43, 63,  0, 61, 53, 59, 50, 42,  1, 63, 47, 43,\n        50, 42,  1, 59, 57,  1, 40, 59, 58,  1, 58, 46, 43,  1, 57, 59, 54, 43,\n        56, 44, 50, 59, 47, 58, 63,  6,  1, 61, 46, 47, 50, 43,  1, 47, 58,  1,\n        61, 43, 56, 43,  0, 61, 46, 53, 50, 43, 57, 53, 51, 43,  6,  1, 61, 43,\n         1, 51, 47, 45, 46, 58,  1, 45, 59, 43, 57, 57,  1, 58, 46, 43, 63,  1,\n        56, 43, 50, 47, 43, 60, 43, 42,  1, 59, 57,  1, 46, 59, 51, 39, 52, 43,\n        50, 63, 11,  0, 40, 59, 58,  1, 58, 46, 43, 63,  1, 58, 46, 47, 52, 49,\n         1, 61, 43,  1, 39, 56, 43,  1, 58, 53, 53,  1, 42, 43, 39, 56, 10,  1,\n        58, 46, 43,  1, 50, 43, 39, 52, 52, 43, 57, 57,  1, 58, 46, 39, 58,  0,\n        39, 44, 44, 50, 47, 41, 58, 57,  1, 59, 57,  6,  1, 58, 46, 43,  1, 53,\n        40, 48, 43, 41, 58,  1, 53, 44,  1, 53, 59, 56,  1, 51, 47, 57, 43, 56,\n        63,  6,  1, 47, 57,  1, 39, 57,  1, 39, 52,  0, 47, 52, 60, 43, 52, 58,\n        53, 56, 63,  1, 58, 53,  1, 54, 39, 56, 58, 47, 41, 59, 50, 39, 56, 47,\n        57, 43,  1, 58, 46, 43, 47, 56,  1, 39, 40, 59, 52, 42, 39, 52, 41, 43,\n        11,  1, 53, 59, 56,  0, 57, 59, 44, 44, 43, 56, 39, 52, 41, 43,  1, 47,\n        57,  1, 39,  1, 45, 39, 47, 52,  1, 58, 53,  1, 58, 46, 43, 51,  1, 24,\n        43, 58,  1, 59, 57,  1, 56, 43, 60, 43, 52, 45, 43,  1, 58, 46, 47, 57,\n         1, 61, 47, 58, 46,  0, 53, 59, 56,  1, 54, 47, 49, 43, 57,  6,  1, 43,\n        56, 43,  1, 61, 43,  1, 40, 43, 41, 53, 51, 43,  1, 56, 39, 49, 43, 57,\n        10,  1, 44, 53, 56,  1, 58, 46, 43,  1, 45, 53, 42, 57,  1, 49, 52, 53,\n        61,  1, 21,  0, 57, 54, 43, 39, 49,  1, 58, 46, 47, 57,  1, 47, 52,  1,\n        46, 59, 52, 45, 43, 56,  1, 44, 53, 56,  1, 40, 56, 43, 39, 42,  6,  1,\n        52, 53, 58,  1, 47, 52,  1, 58, 46, 47, 56, 57, 58,  1, 44, 53, 56,  1,\n        56, 43, 60, 43, 52, 45, 43,  8,  0,  0])\n\n\n\n\nTrain/validation split\n\n\nCode\n# Let's now split up the data into train and validation sets\nn = int(0.9 * len(data))  # first 90% will be train, rest val\ntrain_data = data[:n]\nval_data = data[n:]\n\n\n\n\nCode\nblock_size = 8\n# First block and the target\ntrain_data[:block_size + 1]\n\n\ntensor([18, 47, 56, 57, 58,  1, 15, 47, 58])\n\n\n\n\nCode\n# This is what we want to learn for max_context_size = block_size\n# It is important that we train also for shorter sequences than block_size\n# When creating batches in practice we could need padding token and if pad left or right!\n# Also how to shuffle if we need to if data does not fit in memory: https://blog.janestreet.com/how-to-shuffle-a-big-dataset/\nx = train_data[:block_size]\ny = train_data[1:block_size + 1]\nfor t in range(block_size):\n    context = x[:t + 1]\n    target = y[t]\n    print(f\"when input is {context} the target: {target}\")\n\n\nwhen input is tensor([18]) the target: 47\nwhen input is tensor([18, 47]) the target: 56\nwhen input is tensor([18, 47, 56]) the target: 57\nwhen input is tensor([18, 47, 56, 57]) the target: 58\nwhen input is tensor([18, 47, 56, 57, 58]) the target: 1\nwhen input is tensor([18, 47, 56, 57, 58,  1]) the target: 15\nwhen input is tensor([18, 47, 56, 57, 58,  1, 15]) the target: 47\nwhen input is tensor([18, 47, 56, 57, 58,  1, 15, 47]) the target: 58\n\n\n\n\nBatch generation\n\n\nCode\ntorch.manual_seed(1337)\nbatch_size = 4  # how many independent sequences will we process in parallel?\nblock_size = 8  # what is the maximum context length for predictions?\n\n\ndef get_batch(split_kind: str) -&gt; tuple[Int64[Array, \"n_batches block_size\"], Int64[Array, \"n_batches block_size\"]]:\n    # generate a small batch of data of inputs x and targets y\n    data = train_data if split_kind == 'train' else val_data\n    # Random starting indices of blocks, notice that blocks can overlap\n    # To do something like this for real: \n    ix = torch.randint(len(data) - block_size, (batch_size,))\n    x = torch.stack([data[i:i + block_size] for i in ix])\n    y = torch.stack([data[i + 1:i + block_size + 1] for i in ix])\n    return x, y\n\n\nxb, yb = get_batch('train')\nprint('inputs:')\nprint(xb.shape)\nprint(xb)\nprint('targets:')\nprint(yb.shape)\nprint(yb)\n\nprint('----')\n\nfor b in range(batch_size):  # batch dimension\n    for t in range(block_size):  # time dimension\n        context = xb[b, :t + 1]\n        target = yb[b, t]\n        print(f\"when input is {context.tolist()} the target: {target}\")\n\n\ninputs:\ntorch.Size([4, 8])\ntensor([[24, 43, 58,  5, 57,  1, 46, 43],\n        [44, 53, 56,  1, 58, 46, 39, 58],\n        [52, 58,  1, 58, 46, 39, 58,  1],\n        [25, 17, 27, 10,  0, 21,  1, 54]])\ntargets:\ntorch.Size([4, 8])\ntensor([[43, 58,  5, 57,  1, 46, 43, 39],\n        [53, 56,  1, 58, 46, 39, 58,  1],\n        [58,  1, 58, 46, 39, 58,  1, 46],\n        [17, 27, 10,  0, 21,  1, 54, 39]])\n----\nwhen input is [24] the target: 43\nwhen input is [24, 43] the target: 58\nwhen input is [24, 43, 58] the target: 5\nwhen input is [24, 43, 58, 5] the target: 57\nwhen input is [24, 43, 58, 5, 57] the target: 1\nwhen input is [24, 43, 58, 5, 57, 1] the target: 46\nwhen input is [24, 43, 58, 5, 57, 1, 46] the target: 43\nwhen input is [24, 43, 58, 5, 57, 1, 46, 43] the target: 39\nwhen input is [44] the target: 53\nwhen input is [44, 53] the target: 56\nwhen input is [44, 53, 56] the target: 1\nwhen input is [44, 53, 56, 1] the target: 58\nwhen input is [44, 53, 56, 1, 58] the target: 46\nwhen input is [44, 53, 56, 1, 58, 46] the target: 39\nwhen input is [44, 53, 56, 1, 58, 46, 39] the target: 58\nwhen input is [44, 53, 56, 1, 58, 46, 39, 58] the target: 1\nwhen input is [52] the target: 58\nwhen input is [52, 58] the target: 1\nwhen input is [52, 58, 1] the target: 58\nwhen input is [52, 58, 1, 58] the target: 46\nwhen input is [52, 58, 1, 58, 46] the target: 39\nwhen input is [52, 58, 1, 58, 46, 39] the target: 58\nwhen input is [52, 58, 1, 58, 46, 39, 58] the target: 1\nwhen input is [52, 58, 1, 58, 46, 39, 58, 1] the target: 46\nwhen input is [25] the target: 17\nwhen input is [25, 17] the target: 27\nwhen input is [25, 17, 27] the target: 10\nwhen input is [25, 17, 27, 10] the target: 0\nwhen input is [25, 17, 27, 10, 0] the target: 21\nwhen input is [25, 17, 27, 10, 0, 21] the target: 1\nwhen input is [25, 17, 27, 10, 0, 21, 1] the target: 54\nwhen input is [25, 17, 27, 10, 0, 21, 1, 54] the target: 39\n\n\n\n\nCode\nprint(xb)  # our input to the transformer\n\n\ntensor([[24, 43, 58,  5, 57,  1, 46, 43],\n        [44, 53, 56,  1, 58, 46, 39, 58],\n        [52, 58,  1, 58, 46, 39, 58,  1],\n        [25, 17, 27, 10,  0, 21,  1, 54]])"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#bigram-language-model",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#bigram-language-model",
    "title": "GPT and more from scratch with comments",
    "section": "Bigram language model",
    "text": "Bigram language model\nWhat is the most likely next token given the current token? We are targeting the probability or logit of the next token, given the current token.\n\n\nCode\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\n\ntorch.manual_seed(1337)\n\n\nclass BigramLanguageModel(nn.Module):\n\n    def __init__(self, vocab_size: int):\n        super().__init__()\n        # each token directly reads off the logits for the next token from a lookup table\n        self.token_embedding_table = nn.Embedding(vocab_size, vocab_size)\n\n    def forward(self, idx: Long[torch.Tensor, \"batch_dim context_dim\"],\n                targets: Optional[Long[torch.Tensor, \"batch_dim context_dim\"]] = None):\n\n        # idx and targets are both (B,T) tensor of integers\n        logits: Long[torch.Tensor, \"batch_dim context_dim latent_dim\"] = self.token_embedding_table(\n            idx)  # (B,T,C=vocab_size)\n\n        if targets is None:\n            return logits, None\n        else:\n            # Note that here strictly speaking this does not fix batch size explicitly to B\n            B, T, C = logits.shape  # (B,T,C=vocab_size)\n            # Just a hack to avoid transposing, cross_entropy expects B x C x T in batched mode\n            # This converts into non batched mode\n            logits: Long[torch.Tensor, \"batch_dim*context_dim latent_dim\"] = logits.view(B * T, C)\n            targets: Long[torch.Tensor, \"batch_dim*context_dim\"] = targets.view(B * T)\n            # https://agustinus.kristia.de/techblog/2016/12/21/forward-reverse-kl/\n            loss: Float[torch.Tensor, \"\"] = F.cross_entropy(logits, targets)\n            return logits, loss\n\n    def generate(self, idx: Long[torch.Tensor, \"batch_dim context_dim\"], max_new_tokens: int):\n        # idx is (B, T) array of indices in the current context\n        for _ in range(max_new_tokens):\n            # get the predictions\n            logits, loss = self(idx)\n            # focus only on the last time step\n            logits = logits[:, -1, :]  # becomes (B, vocab_size)\n            # apply softmax to get probabilities\n            probs = F.softmax(logits, dim=-1)  # (B, vocab_size)\n            # sample from the distribution\n            idx_next = torch.multinomial(probs, num_samples=1)  # (B, 1)\n            # append sampled index to the running sequence\n            idx = torch.cat((idx, idx_next), dim=1)  # (B, T+1)\n            # What can go wrong here? and it is not handled at all\n        return idx\n\n\nm = BigramLanguageModel(vocab_size)\nlogits, loss = m(xb, yb)\nprint(logits.shape)\nprint(loss)\nprint(loss.shape)\nprint(decode(m.generate(idx=torch.zeros((1, 1), dtype=torch.long), max_new_tokens=100)[0].tolist()))\n\n\ntorch.Size([32, 65])\ntensor(4.8786, grad_fn=&lt;NllLossBackward0&gt;)\ntorch.Size([])\n\nSr?qP-QWktXoL&jLDJgOLVz'RIoDqHdhsV&vLLxatjscMpwLERSPyao.qfzs$Ys$zF-w,;eEkzxjgCKFChs!iWW.ObzDnxA Ms$3\n\n\n\n\nCode\n### Optimization using AdamW and cross entropy\n\n\n\n\nCode\n# create a PyTorch optimizer\noptimizer = torch.optim.AdamW(m.parameters(), lr=1e-3)\n# weighted average of mean and \"variance\" of gradients +  a trick\n# Not feasible for deep learning, too costly to store harder to parallelize!\n# https://en.wikipedia.org/wiki/Limited-memory_BFGS approximates inverse of Hessian implicitly and even this is too costly\n# https://en.wikipedia.org/wiki/Wolfe_conditions\n# https://en.wikipedia.org/wiki/Backtracking_line_search more advanced step size\n\n\n\n\nCode\nbatch_size = 32\nn_steps = 1_000\nfor steps in range(n_steps):  # increase number of steps for good results...\n\n    # sample a batch of data\n    xb, yb = get_batch('train')\n\n    # evaluate the loss\n    logits, loss = m(xb, yb)\n    optimizer.zero_grad(set_to_none=True)\n    loss.backward()\n    optimizer.step()\n\nprint(loss.item())\n\n\n3.7218432426452637\n\n\n\n\nCode\nprint(decode(m.generate(idx=torch.zeros((1, 1), dtype=torch.long), max_new_tokens=500)[0].tolist()))\n\n\n\nolylvLLko'TMyatyIoconxad.?-tNSqYPsx&bF.oiR;BD$dZBMZv'K f bRSmIKptRPly:AUC&$zLK,qUEy&Ay;ZxjKVhmrdagC-bTop-QJe.H?x\nJGF&pwst-P sti.hlEsu;w:w a BG:tLhMk,epdhlay'sVzLq--ERwXUzDnq-bn czXxxI&V&Pynnl,s,Ioto!uvixwC-IJXElrgm C-.bcoCPJ\nIMphsevhO AL!-K:AIkpre,\nrPHEJUzV;P?uN3b?ohoRiBUENoV3B&jumNL;Aik,\nxf -IEKROn JSyYWW?n 'ay;:weO'AqVzPyoiBL? seAX3Dot,iy.xyIcf r!!ul-Koi:x pZrAQly'v'a;vEzN\nBwowKo'MBqF$PPFb\nCjYX3beT,lZ qdda!wfgmJP\nDUfNXmnQU mvcv?nlnQF$JUAAywNocd  bGSPyAlprNeQnq-GRSVUP.Ja!IBoDqfI&xJM AXEHV&DKvRS"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#the-mathematical-formulation-of-causal-self-attention",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#the-mathematical-formulation-of-causal-self-attention",
    "title": "GPT and more from scratch with comments",
    "section": "The mathematical formulation of (causal) self-attention",
    "text": "The mathematical formulation of (causal) self-attention\n\n\nCode\n# toy example illustrating how matrix multiplication can be used for a \"weighted aggregation\"\ntorch.manual_seed(42)\n# Causal attention does not take into account future information\na = torch.tril(torch.ones(3, 3))\na = a / torch.sum(a, 1, keepdim=True)\nb = torch.randint(0, 10, (3, 2)).float()\nc = a @ b\nprint('a=')\nprint(a)\nprint('--')\nprint('b=')\nprint(b)\nprint('--')\nprint('c=')\nprint(c)\n\n\na=\ntensor([[1.0000, 0.0000, 0.0000],\n        [0.5000, 0.5000, 0.0000],\n        [0.3333, 0.3333, 0.3333]])\n--\nb=\ntensor([[2., 7.],\n        [6., 4.],\n        [6., 5.]])\n--\nc=\ntensor([[2.0000, 7.0000],\n        [4.0000, 5.5000],\n        [4.6667, 5.3333]])\n\n\n\n\nCode\n# consider the following toy example:\n\ntorch.manual_seed(1337)\nB, T, C = 4, 8, 2  # batch, time, channels\nx = torch.randn(B, T, C)\nx.shape\n\n\ntorch.Size([4, 8, 2])\n\n\n\nManual aggregation\n\n\nCode\n# We want $x[b,t] = mean_{i&lt;=t} x[b,i]$\nxbow = torch.zeros((B, T, C))\nfor b in range(B):\n    for t in range(T):\n        xprev = x[b, :t + 1]  # (t,C)\n        xbow[b, t] = torch.mean(xprev, 0)\n\n\n\n\nMatrix multiply for weighted aggregation\n\n\nCode\n# version 2: using matrix multiply for a weighted aggregation\nwei = torch.tril(torch.ones(T, T))\nwei = wei / wei.sum(1, keepdim=True)\nxbow2 = wei @ x  # (B, T, T) @ (B, T, C) ----&gt; (B, T, C)\n# Numerical instability and float32 only, need to set lower relative accuracy\ntorch.allclose(xbow, xbow2, 1e-4)\n\n\nTrue\n\n\n\n\nCode\n### Softmax for weighted aggregation\n\n\n\n\nCode\n# version 3: use Softmax\ntril = torch.tril(torch.ones(T, T))\nwei = torch.zeros((T, T))\n# This seems strange at first glance but exp(-inf) = 0 and it is well defined, otherwise training would get broken constantly\nwei = wei.masked_fill(tril == 0, float('-inf'))\nwei = F.softmax(wei, dim=-1)\nxbow3 = wei @ x\n# Numerical instability and float32 only, need to set lower relative accuracy\ntorch.allclose(xbow, xbow3, 1e-4)\n\n\nTrue\n\n\n\n\nSelf attention\n\\[\\texttt{Attention}(Q, K, V) = \\texttt{softmax}(\\frac{QK^T}{\\sqrt{d_k}})V,\\] where \\(\\sqrt{d_k}\\) is the dimension of the key vector \\(k\\) and query vector \\(q\\). The causal version can only take into account current and past tokens se we need to mask all future token inputs so that they not influence the prediction of the next token. This can be accomplished by triangular mask.\n\n\nMulti head attention\n\\[\\texttt{MultiHead}(Q, K, V) = \\texttt{Concat}(\\texttt{head}_1, ..., \\texttt{head}_h)W^O,\\] where \\[\\texttt{head}_i = \\texttt{Attention}(Q W^Q_i, K W^K_i, V W^V_i).\\]\nModifed from ML equations in latex. As a note, the vectors are rows and not columns like in Matlab.\n\n\nCode\n# version 4: self-attention!\ntorch.manual_seed(1337)\nB, T, C = 4, 8, 32  # batch, time, channels\nx = torch.randn(B, T, C)\n\n# let's see a single Head perform self-attention\nhead_size = 16\nkey = nn.Linear(C, head_size, bias=False)\nquery = nn.Linear(C, head_size, bias=False)\nvalue = nn.Linear(C, head_size, bias=False)\nk = key(x)  # (B, T, 16)\nq = query(x)  # (B, T, 16)\nwei = q @ k.transpose(-2, -1)  # (B, T, 16) @ (B, 16, T) ---&gt; (B, T, T)\n\ntril = torch.tril(torch.ones(T, T))\n# wei = torch.zeros((T,T))\n# Full matrix multiplication is faster, just block what we do not need\nwei = wei.masked_fill(tril == 0, float('-inf'))\nwei = F.softmax(wei, dim=-1)\n\nv = value(x)\nout = wei @ v\n# out = wei @ x\n\nout.shape\n\n\ntorch.Size([4, 8, 16])\n\n\n\n\nCode\nwei[0]\n\n\ntensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.1574, 0.8426, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.2088, 0.1646, 0.6266, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.5792, 0.1187, 0.1889, 0.1131, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.0294, 0.1052, 0.0469, 0.0276, 0.7909, 0.0000, 0.0000, 0.0000],\n        [0.0176, 0.2689, 0.0215, 0.0089, 0.6812, 0.0019, 0.0000, 0.0000],\n        [0.1691, 0.4066, 0.0438, 0.0416, 0.1048, 0.2012, 0.0329, 0.0000],\n        [0.0210, 0.0843, 0.0555, 0.2297, 0.0573, 0.0709, 0.2423, 0.2391]],\n       grad_fn=&lt;SelectBackward0&gt;)"
  },
  {
    "objectID": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#notes",
    "href": "posts/24_05_2024_gpt2_from_scratch/gpt_dev.html#notes",
    "title": "GPT and more from scratch with comments",
    "section": "Notes:",
    "text": "Notes:\n\nAttention is a communication mechanism. Can be seen as nodes in a directed graph looking at each other and aggregating information with a weighted sum from all nodes that point to them, with data-dependent weights.\nThere is no notion of space. Attention simply acts over a set of vectors. This is why we need to positionally encode tokens.\nEach example across batch dimension is of course processed completely independently and never “talk” to each other\nIn an “encoder” attention block just delete the single line that does masking with tril, allowing all tokens to communicate. This block here is called a “decoder” attention block because it has triangular masking, and is usually used in autoregressive settings, like language modeling.\n“self-attention” just means that the keys and values are produced from the same source as queries. In “cross-attention”, the queries still get produced from x, but the keys and values come from some other, external source (e.g. an encoder module)\n“Scaled” attention additionally divides wei by 1/sqrt(head_size). This makes it so when input Q,K are unit variance, wei will be unit variance too and Softmax will stay diffuse and not saturate too much. Illustration below’’\n\n\n\nCode\n# head_size is the dimension of \"latent space\"\nk = torch.randn(B, T, head_size)\nq = torch.randn(B, T, head_size)\nwei = q @ k.transpose(-2, -1) * head_size ** -0.5\n\n\n\n\nCode\nk.var()\n\n\ntensor(1.0449)\n\n\n\n\nCode\nq.var()\n\n\ntensor(1.0700)\n\n\n\n\nCode\nwei.var()\n\n\ntensor(1.0918)\n\n\n\n\nCode\ntorch.softmax(torch.tensor([0.1, -0.2, 0.3, -0.2, 0.5]), dim=-1)\n\n\ntensor([0.1925, 0.1426, 0.2351, 0.1426, 0.2872])\n\n\n\n\nCode\ntorch.softmax(torch.tensor([0.1, -0.2, 0.3, -0.2, 0.5]) * 8, dim=-1)  # gets too peaky, converges to one-hot\n\n\ntensor([0.0326, 0.0030, 0.1615, 0.0030, 0.8000])\n\n\n\n\nCode\nclass LayerNorm1d:  # (used to be BatchNorm1d)\n\n    def __init__(self, dim, eps=1e-5, momentum=0.1):\n        self.eps = eps\n        self.gamma = torch.ones(dim)\n        self.beta = torch.zeros(dim)\n\n    def __call__(self, x):\n        # calculate the forward pass\n        xmean = x.mean(1, keepdim=True)  # batch mean\n        xvar = x.var(1, keepdim=True)  # batch variance\n        xhat = (x - xmean) / torch.sqrt(xvar + self.eps)  # normalize to unit variance\n        self.out = self.gamma * xhat + self.beta\n        return self.out\n\n    def parameters(self):\n        return [self.gamma, self.beta]\n\n\ntorch.manual_seed(1337)\nmodule = LayerNorm1d(100)\n# batch_norm_1d = nn.BatchNorm1d(100)\n# x_normalized_torch = batch_norm_1d(x)\n\nx = torch.randn(32, 100)  # batch size 32 of 100-dimensional vectors\nx_normalized = module(x)\nx_normalized.shape\n\n\ntorch.Size([32, 100])\n\n\n\n\nCode\nx[:, 0].mean(), x[:, 0].std()  # mean,std of one feature across all batch inputs\n\n\n(tensor(0.1392), tensor(0.8899))\n\n\n\n\nCode\nx[0, :].mean(), x[0, :].std()  # mean,std of a single input from the batch, of its features\n\n\n(tensor(0.0409), tensor(1.0476))\n\n\n# French to English translation example:\n\n# &lt;--------- ENCODE ------------------&gt;&lt;--------------- DECODE -----------------&gt;\n# les réseaux de neurones sont géniaux! &lt;START&gt; neural networks are awesome!&lt;END&gt;\n\nFull finished code, for reference\nYou may want to refer directly to the Karpathy’s git repo or use NanoGPT instead though.\n\n\nCode\nimport math\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\n\n# hyperparameters\nbatch_size = 1024 # 16  # how many independent sequences will we process in parallel?\nblock_size = 128 # 32  # what is the maximum context length for predictions?\nmax_iters = 10000\neval_interval = 100\nlearning_rate = 1e-3\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\neval_iters = 200\nn_embd = 64\nn_head = 4\nn_layer = 4\ndropout = 0.2\n# ------------\n\ntorch.manual_seed(1337)\n\n# wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt\nsave_path = Path('~').expanduser() / f'.cache/input.txt'\nif not save_path.exists():\n    !wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt -O {save_path}\n\n# here are all the unique characters that occur in this text\nchars = sorted(list(set(text)))\nvocab_size = len(chars)\n# create a mapping from characters to integers\nstoi = {ch: i for i, ch in enumerate(chars)}\nitos = {i: ch for i, ch in enumerate(chars)}\nencode = lambda s: [stoi[c] for c in s]  # encoder: take a string, output a list of integers\ndecode = lambda l: ''.join([itos[i] for i in l])  # decoder: take a list of integers, output a string\n\n# Train and test splits\ndata = torch.tensor(encode(text), dtype=torch.long)\nn = int(0.9 * len(data))  # first 90% will be train, rest val\ntrain_data = data[:n]\nval_data = data[n:]\n\n\n# data loading\ndef get_batch(split):\n    # generate a small batch of data of inputs x and targets y\n    data = train_data if split == 'train' else val_data\n    ix = torch.randint(len(data) - block_size, (batch_size,))\n    x = torch.stack([data[i:i + block_size] for i in ix])\n    y = torch.stack([data[i + 1:i + block_size + 1] for i in ix])\n    x, y = x.to(device), y.to(device)\n    return x, y\n\n\n@torch.no_grad()\ndef estimate_loss():\n    out = {}\n    model.eval()\n    for split in ['train', 'val']:\n        losses = torch.zeros(eval_iters)\n        for k in range(eval_iters):\n            X, Y = get_batch(split)\n            logits, loss = model(X, Y)\n            losses[k] = loss.item()\n        out[split] = losses.mean()\n    model.train()\n    return out\n\n\nclass Head(nn.Module):\n    \"\"\" one head of self-attention\n        https://magazine.sebastianraschka.com/p/understanding-and-coding-self-attention\n    \"\"\"\n\n    def __init__(self, head_size):\n        super().__init__()\n        self.key = nn.Linear(n_embd, head_size, bias=False)\n        self.query = nn.Linear(n_embd, head_size, bias=False)\n        self.value = nn.Linear(n_embd, head_size, bias=False)\n        # This limits us to the maximal context block_size\n        self.register_buffer('tril', torch.tril(torch.ones(block_size, block_size)))\n\n        self.dropout = nn.Dropout(dropout)\n\n    def forward(self, x):\n        B, T, C = x.shape\n        k = self.key(x)  # (B,T,C=n_embd) -&gt; (B,T,C=head_size)\n        q = self.query(x)  # (B,T,C=n_embd) -&gt; (B,T,C=head_size)\n        # compute attention scores (\"affinities\")\n        wei = q @ k.transpose(-2, -1) * C ** -0.5  # (B, T, C=head_size) @ (B, C=head_size), T) -&gt; (B, T, T)\n        wei = wei.masked_fill(self.tril[:T, :T] == 0, float('-inf'))  # (B, T, T)\n        wei = F.softmax(wei, dim=-1)  # (B, T, T)\n        # The drop out is over full matrix, alternatively it would be better to just drop on mask, this is biased\n        # Also it seems maybe conceptually we should just do symmetric dropout\n        wei = self.dropout(wei)\n        # perform the weighted aggregation of the values\n        v = self.value(x)  # (B,T,C=head_size)\n        # The matrix multiplication is batched and applied on last two dimensions!\n        out = wei @ v  # (B, T, T) @ (B, T, C=head_size) -&gt; (B, T, C=head_size)\n        return out\n\n\nclass MultiHeadAttention(nn.Module):\n    \"\"\" multiple heads of self-attention in parallel \"\"\"\n\n    def __init__(self, num_heads, head_size):\n        super().__init__()\n        self.heads = nn.ModuleList([Head(head_size) for _ in range(num_heads)])\n        # Projection back to residual pathway, align the basis\n        self.proj = nn.Linear(n_embd, n_embd)\n        self.dropout = nn.Dropout(dropout)\n\n    def forward(self, x):\n        out = torch.cat([h(x) for h in self.heads], dim=-1)\n        out = self.dropout(self.proj(out))\n        return out\n\n\nclass FeedFoward(nn.Module):\n    \"\"\" a simple linear layer followed by a non-linearity \"\"\"\n\n    def __init__(self, n_embd):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(n_embd, 4 * n_embd),\n            nn.ReLU(),\n            nn.Linear(4 * n_embd, n_embd), # Projection back to residual pathway\n            nn.Dropout(dropout),\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\nclass Block(nn.Module):\n    \"\"\" Transformer block: communication followed by computation \"\"\"\n\n    def __init__(self, n_embd: int, n_head: int):\n        # n_embd: embedding dimension, n_head: the number of heads we'd like\n        super().__init__()\n        # To guarantee that final concatenated embedding is of size n_embd \n        head_size = n_embd // n_head\n        self.sa = MultiHeadAttention(n_head, head_size)\n        self.ffwd = FeedFoward(n_embd)\n        self.ln1 = nn.LayerNorm(n_embd)\n        self.ln2 = nn.LayerNorm(n_embd)\n\n    def forward(self, x):\n        # Skip connections added to improve the flow of gradient\n        # Need to project back to residual pathway in sa and ffwd to \"align bases\" \n        \n        # Modern way is do to layer norm before and not after, in original paper it was done after, we do before!\n        x = x + self.sa(self.ln1(x))\n        x = x + self.ffwd(self.ln2(x))\n        return x\n\n\n# Not so super simple and not bigram model anymore\nclass GPT2LanguageModel(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n        # each token is mapped to latent space of size n_embd\n        self.token_embedding_table = nn.Embedding(vocab_size, n_embd)\n        # learnable position embedding for positions 0, ..., block_size - 1\n        self.position_embedding_table = nn.Embedding(block_size, n_embd)\n        # Modern way of handling this is:\n        # https://machinelearningmastery.com/a-gentle-introduction-to-positional-encoding-in-transformer-models-part-1/\n        # https://afterhoursresearch.hashnode.dev/rope-rotary-positional-embedding\n        self.blocks = nn.Sequential(*[Block(n_embd, n_head=n_head) for _ in range(n_layer)])\n        self.ln_f = nn.LayerNorm(n_embd)  # final layer norm\n        self.lm_head = nn.Linear(n_embd, vocab_size, bias=False)\n        \n        # init all weights, and apply a special scaled init to the residual projections, per GPT-2 paper\n        self.apply(self._init_weights)\n        for pn, p in self.named_parameters():\n            if pn.endswith('proj.weight'):\n                torch.nn.init.normal_(p, mean=0.0, std=0.02/math.sqrt(2 * n_layer))\n                \n    def _init_weights(self, module):\n        # Not really needed but with this in the convergence is faster\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def forward(self, idx, targets=None):\n        B, T = idx.shape\n\n        # idx and targets are both (B,T) tensor of integers\n        tok_emb = self.token_embedding_table(idx)  # (B,T,C=n_embd)\n        pos_emb = self.position_embedding_table(torch.arange(T, device=device))  # (T,C=n_embd)\n        x = tok_emb + pos_emb  # (B,T,C=n_embd)\n        x = self.blocks(x)  # (B,T,C=n_embd)\n        # Modern way is do to layer norm before and not after, in original paper it was done after, we do before!\n        x = self.ln_f(x)  # (B,T,C=n_embd)\n        logits = self.lm_head(x)  # (B,T,vocab_size)\n\n        if targets is None:\n            loss = None\n        else:\n            B, T, C = logits.shape\n            logits = logits.view(B * T, C)\n            targets = targets.view(B * T)\n            loss = F.cross_entropy(logits, targets)\n\n        return logits, loss\n\n    def generate(self, idx, max_new_tokens):\n        # idx is (B, T) array of indices in the current context\n        for _ in range(max_new_tokens):\n            # crop idx to the last block_size tokens, otherwise things will explode\n            idx_cond = idx[:, -block_size:]\n            # get the predictions\n            logits, loss = self(idx_cond)\n            # focus only on the last time step\n            logits = logits[:, -1, :]  # (B, T, C=vocab_size) becomes (B, C=vocab_size)\n            # apply softmax to get probabilities\n            probs = F.softmax(logits, dim=-1)  # (B, C=vocab_size)\n            # sample from the multinomial distribution\n            idx_next = torch.multinomial(probs, num_samples=1)  # (B, 1)\n            # append sampled index to the running sequence\n            idx = torch.cat((idx, idx_next), dim=1)  # (B, T+1)\n        return idx\n\n\nmodel = GPT2LanguageModel()\nm = model.to(device)\n# print the number of parameters in the model\nprint(sum(p.numel() for p in m.parameters()) / 1e6, 'M parameters')\n\n# create a PyTorch optimizer\n# https://www.ruder.io/optimizing-gradient-descent/#adam\n# https://iclr-blogposts.github.io/2023/blog/2023/adamw/\noptimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)\n\nfor iter in range(max_iters):\n\n    # every once in a while evaluate the loss on train and val sets\n    if iter % eval_interval == 0 or iter == max_iters - 1:\n        losses = estimate_loss()\n        print(f\"step {iter}: train loss {losses['train']:.4f}, val loss {losses['val']:.4f}\")\n\n    # sample a batch of data\n    xb, yb = get_batch('train')\n\n    # evaluate the loss\n    logits, loss = model(xb, yb)\n    optimizer.zero_grad(set_to_none=True)\n    loss.backward()\n    optimizer.step()\n\n# generate from the model\ncontext = torch.zeros((1, 1), dtype=torch.long, device=device)\nprint(decode(m.generate(context, max_new_tokens=2000)[0].tolist()))\n# Temperature motivation https://en.wikipedia.org/wiki/LogSumExp\n# What happens when you divide logits by posite Temp and then do softmax\n# Temp close to 0 is max in limit, one hot, Temp &gt;&gt; 1 in limit random\n\n\n0.215808 M parameters\nstep 0: train loss 4.1890, val loss 4.1885\nstep 100: train loss 2.5203, val loss 2.5128\nstep 200: train loss 2.2087, val loss 2.2280\nstep 300: train loss 1.9885, val loss 2.0614\nstep 400: train loss 1.7996, val loss 1.9230\nstep 500: train loss 1.7208, val loss 1.8648\nstep 600: train loss 1.6610, val loss 1.8272\nstep 700: train loss 1.6218, val loss 1.7936\nstep 800: train loss 1.5859, val loss 1.7645\nstep 900: train loss 1.5593, val loss 1.7374\nstep 1000: train loss 1.5727, val loss 1.7391\nstep 1100: train loss 1.5257, val loss 1.7019\nstep 1200: train loss 1.5101, val loss 1.6936\nstep 1300: train loss 1.5033, val loss 1.6867\nstep 1400: train loss 1.4825, val loss 1.6667\nstep 1500: train loss 1.4743, val loss 1.6577\nstep 1600: train loss 1.4717, val loss 1.6572\nstep 1700: train loss 1.4584, val loss 1.6505\nstep 1800: train loss 1.4466, val loss 1.6353\nstep 1900: train loss 1.4423, val loss 1.6301\nstep 2000: train loss 1.4483, val loss 1.6326\nstep 2100: train loss 1.4322, val loss 1.6291\nstep 2200: train loss 1.4267, val loss 1.6201\nstep 2300: train loss 1.4237, val loss 1.6142\nstep 2400: train loss 1.4157, val loss 1.6069\nstep 2500: train loss 1.4104, val loss 1.6050\nstep 2600: train loss 1.4105, val loss 1.6065\nstep 2700: train loss 1.4058, val loss 1.6060\nstep 2800: train loss 1.4023, val loss 1.5983\nstep 2900: train loss 1.3992, val loss 1.5967\nstep 3000: train loss 1.3964, val loss 1.5929\nstep 3100: train loss 1.3934, val loss 1.5959\nstep 3200: train loss 1.3905, val loss 1.5892\nstep 3300: train loss 1.3861, val loss 1.5817\nstep 3400: train loss 1.3873, val loss 1.5865\nstep 3500: train loss 1.3850, val loss 1.5846\nstep 3600: train loss 1.3816, val loss 1.5820\nstep 3700: train loss 1.3786, val loss 1.5816\nstep 3800: train loss 1.3778, val loss 1.5762\nstep 3900: train loss 1.3747, val loss 1.5735\nstep 4000: train loss 1.3722, val loss 1.5791\nstep 4100: train loss 1.3727, val loss 1.5765\nstep 4200: train loss 1.3725, val loss 1.5795\nstep 4300: train loss 1.3736, val loss 1.5785\nstep 4400: train loss 1.3675, val loss 1.5717\nstep 4500: train loss 1.3649, val loss 1.5684\nstep 4600: train loss 1.3663, val loss 1.5669\nstep 4700: train loss 1.3611, val loss 1.5657\nstep 4800: train loss 1.3614, val loss 1.5636\nstep 4900: train loss 1.3591, val loss 1.5697\nstep 5000: train loss 1.3640, val loss 1.5737\nstep 5100: train loss 1.8337, val loss 1.9548\nstep 5200: train loss 1.3989, val loss 1.6005\nstep 5300: train loss 1.3727, val loss 1.5784\nstep 5400: train loss 1.3656, val loss 1.5752\nstep 5500: train loss 1.3609, val loss 1.5700\nstep 5600: train loss 1.3588, val loss 1.5663\nstep 5700: train loss 1.3558, val loss 1.5678\nstep 5800: train loss 1.3536, val loss 1.5654\nstep 5900: train loss 1.3526, val loss 1.5655\nstep 6000: train loss 1.3500, val loss 1.5611\nstep 6100: train loss 1.3543, val loss 1.5676\nstep 6200: train loss 1.3485, val loss 1.5605\nstep 6300: train loss 1.3472, val loss 1.5632\nstep 6400: train loss 1.3463, val loss 1.5652\nstep 6500: train loss 1.3445, val loss 1.5602\nstep 6600: train loss 1.3436, val loss 1.5604\nstep 6700: train loss 1.3427, val loss 1.5672\nstep 6800: train loss 1.3439, val loss 1.5627\nstep 6900: train loss 1.3393, val loss 1.5595\nstep 7000: train loss 1.3419, val loss 1.5651\nstep 7100: train loss 1.3409, val loss 1.5611\nstep 7200: train loss 1.3427, val loss 1.5649\nstep 7300: train loss 1.3393, val loss 1.5593\nstep 7400: train loss 1.3360, val loss 1.5573\nstep 7500: train loss 1.3405, val loss 1.5673\nstep 7600: train loss 1.3387, val loss 1.5630\nstep 7700: train loss 1.3365, val loss 1.5624\nstep 7800: train loss 1.3336, val loss 1.5640\nstep 7900: train loss 1.3351, val loss 1.5637\nstep 8000: train loss 1.3350, val loss 1.5658\nstep 8100: train loss 1.3320, val loss 1.5566\nstep 8200: train loss 1.3315, val loss 1.5572\nstep 8300: train loss 1.3321, val loss 1.5573\nstep 8400: train loss 1.3321, val loss 1.5650\nstep 8500: train loss 1.3326, val loss 1.5600\nstep 8600: train loss 1.3325, val loss 1.5667\nstep 8700: train loss 1.3300, val loss 1.5573\nstep 8800: train loss 1.3289, val loss 1.5581\nstep 8900: train loss 1.3289, val loss 1.5621\nstep 9000: train loss 1.3276, val loss 1.5536\nstep 9100: train loss 1.3263, val loss 1.5544\nstep 9200: train loss 1.3284, val loss 1.5636\nstep 9300: train loss 1.3270, val loss 1.5552\nstep 9400: train loss 1.3262, val loss 1.5569\nstep 9500: train loss 1.3264, val loss 1.5593\nstep 9600: train loss 1.3250, val loss 1.5538\nstep 9700: train loss 1.3251, val loss 1.5588\nstep 9800: train loss 1.3245, val loss 1.5568\nstep 9900: train loss 1.3228, val loss 1.5628\nstep 9999: train loss 1.3235, val loss 1.5614\n\n\nDUKE Venery to tiege's nague will in him.\nGo, lamen, were no my none, I'll faith? Lower.\n\nNORTHUMBY:\nI am proper: and thy rain for chaired\nBefice, gone\nHear years; yet sail a inferous to orguate.\n\nJULIET:\nHere your daminate to the people, and,\nThey have. Marry begind-because you\nSweing a wealth. Poor Clareretian seed:\nBut, care widownest us?\n\nMenen, no surpose him: why, hither, venteren, he is it\nsweet a fall furthy this own, therefore I not in\nit.\n\nPRINCE ERKICHARD:\nA least thee loved a kise of licke worth\nBegain and at so sceedd the weakning sight.\n\nROMEO.\n\nRush on vailships the and the eny-I swir,\nFor awil truthfus, both unflowers there to be would\nsussles than at the goodlor. Al tell; besimes\nTo his bearet win a both toes,\nAnd love to soldie the deckoodly for a\nwhence have Stay 'gawd very.\nFathely we should go break up.'\n\nMost in his friend all.\n\nCORIOLANUS:\nThou play there must it wilt not\nTo foot twell more my eear of Bolingbroke,\nAn all with suilench' thou may two Preasage!\n\nServer I will so happy of our bardled\nConter mine strik's too the good rogues,\nAnd kear pout of my heart yea bed.\nThat's is all, for in the bross them sead?\nDid darers o stands yours, are I be for you;\nSheppale knows much ding sighs made a should bear\nTo shall proft-my gantlen.\n\nFesorow, if you be a conseged a hour, bastand I\nHave this sheople, nor Hanry must might of my sovet?\n\nGLOUCESTER:\nWhat, mercy on'tis treather it was a fortnes?\nAlp you my royal, sin, in say.\nWithing al toffull my virguide could, as't.\n\nKING RICHARD:\nBring gracious loves sothers, throate i' the\nThat\nWould parinage to secrif' the bloody sigh, and there,\nWho stand, unimation their aven ever pleasure\nFriend-compet As he bed: you was fold from\nAnd that fair or was him, to to preasures,\nTo pranset thy love. But, the loators' tear,\nWere not and that tell the depop, not cheel?\narklains overy clorge tack in mail buill\nWith ward her brother'd a dear ClifLo,\nYou shall perincation, and you are at noble.\n\nBAHORSON:\nServant it\n\n\n\n\nDraw the model graph\n\n\nCode\n# https://github.com/szagoruyko/pytorchviz\n# https://github.com/mert-kurttutan/torchview nicer graph\nfrom torchview import draw_graph\nimport torchlens as tl\n\n# device='meta' -&gt; no memory is consumed for visualization\nprint(xb.shape)\nprint(yb.shape)\nmodel_graph = draw_graph(model, input_data=(xb, yb), device='cuda')\nmodel_graph.visual_graph\nsave = True\nsave_path = Path('~/.cache').expanduser()\nif save:\n    torch.save(model.state_dict(), save_path / 'gpt2.pt')\n    torch.save(optimizer.state_dict(), save_path / 'gpt2_opt.pt')\n# model_history = tl.log_forward_pass(model, (xb, yb)\n#                                      , layers_to_save='all', vis_opt='unrolled')\n# print(model_history)\n\n\ntorch.Size([1024, 128])\ntorch.Size([1024, 128])\n\n\n\n\nCode\n# generate from the model\n# Put to evaluation mode to set Dropout to evaluation mode\nmodel.eval()\ncontext = torch.zeros((1, 1), dtype=torch.long, device=device)\nprint(decode(model.generate(context, max_new_tokens=2000)[0].tolist()))\n\n\n\nLUCIO:\nNor attume to the whrewnty-shall not doubt good weak\nThe pluck all on thee on thy heart, much serping.\n\nGLOUCESTER:\nCome, he shall be hears that should speak of phyself\nFrom humble and achery a heaver'd mirth,\nContice.\n\nKING RICHARD IIV:\nIntil you have 'tis their head.\n\nJOHN OF GAUNT:\nThey have beart a praise and vals to see yourself;\nAnd not to depose it, and, sweet before\nThe gown of the sentigal of house,\nMight he shall, by where are to be yet?\n\nFirst Keeper:\nWhat is envy of our dead, for England.\n\nSecond Murderess:\nA kind; he will may be conclifed thee.\n\nClown:\nThem thrust I cannot be say, if I came; away.\nWhy, sir, when then stufff that's life\nReportence wings, were if he seek!\n\nJULIET:\nThis pass good time love more.\n\nSecond Servant:\nO, he fited upon the voice,\nAnd which a bed-will place, by the hinnguns\nhite such rumation.\n\nSecond Gentleman:\nThey have\nBut ear to such our burths is friend could rewith.\n\nHORTENSIO:\nOne shall say, think yet shall thy least from my good grace!\n\nESCALUS:\nI would go then, stand good as as to so.\n\nDUKE VINCENTIO:\nAnd was thry face: I'll not condry.\nWhat proudy the great of the port, affter,\nAnd I cired so thee soul, that farewell have;\nParged him me with quite her the accussed,\nAnd with a montages. Thy spacress her peace\nOf to their moother friends, and lucks: there,\nWhen we dare any with English uncle Mighcaster!\nWhat's remosted on unterty father whom\nthe pregned neck it that is be to be\nI a joy of crown, of a fear he imposited.\n\nPERDITA:\nFoul came to Hacking so dispubble valm,\nThan away?\n\nBUCKINGHAM:\nAy, lot leave?\n\nJULIET:\nHere ever Rome, follow which even lives a sickning\nWhich of execut. Away they swift from you fame\nAnd not thee, or in as a beding thee?\n\nSecond Citizen:\nHere, he's sir; fooly lives' false will,\nStrit, sir. Thou must to fe did death.\n\nDUKE VINCENTIO:\nI fear. Theu do, you, thou love--\nGentleman we, victory of my head did for all,\nThey shall call to the king noble Romeo.\n\nShore.\n\nLUCIO:\nYou canst and a shall"
  },
  {
    "objectID": "posts/30_5_2024_generating_all_primes/generating_all_primes.html",
    "href": "posts/30_5_2024_generating_all_primes/generating_all_primes.html",
    "title": "Formula that generates all primes",
    "section": "",
    "text": "Fun fact, one possible formula that generates all primes, \\(2\\) many times is: \\[2+\\left( (2 \\times  (n-1)!) \\bmod n \\right)\\] Prime numbers are numbers that have only \\(1\\) and itself as divisors like, \\(2, 3, 5, 7, 11, \\dots.\\) Sadly formula is very inefficient and there are a lot more efficient algorithms to check if \\(n\\) is prime. Maybe story for another time. Mod n operator computes the remainder of target number when doing the division by n, like \\(14 \\mod 5 = 4\\) as \\(14 = 2 \\times 5 + 4.\\)"
  },
  {
    "objectID": "posts/30_5_2024_generating_all_primes/generating_all_primes.html#proof-using-wilsons-theorem",
    "href": "posts/30_5_2024_generating_all_primes/generating_all_primes.html#proof-using-wilsons-theorem",
    "title": "Formula that generates all primes",
    "section": "Proof using Wilson’s theorem",
    "text": "Proof using Wilson’s theorem\nOne possible but boring way of proving this is just by using the Wilson’s theorem directly, which says that: \\[ (n-1)! + 1 \\mod n = 0 \\Leftrightarrow n \\texttt{ is a prime} \\Leftrightarrow (n-1)! \\mod n = n-1 \\mod n = -1.\\]\nLet us expand, when \\(n=p\\) and \\(p\\) is a prime: \\[\\left(2 \\times  (n-1)! \\bmod n \\right) = \\left(2 \\times  (p-1)! \\bmod p \\right) = -2 \\mod p = p - 2.\\] Thus for the above we end up with \\(2 + (p-2) = p\\) if \\(p\\) is a prime.\nIf \\(n\\) is not a prime and even, then \\((n-1)!\\) has a factor \\(\\frac{n}{2}\\) and thus \\(2 \\times (n-1)! \\mod n = 0 \\neq -2 \\mod n\\)\nIf \\(n = 2 \\times k + 1\\) is not a prime and odd, \\(n = a \\times b, \\; a \\leq b,\\) then \\(a, b\\) are one of the factors in \\(2(n-1)!\\) and \\(2 \\times (n-1)! \\mod n = 0 \\neq -2 \\mod n\\)\nAs a note even if \\(a=b\\) then \\(a=(a+1-1)\\) is a direct factor and at least one another one is \\(a=2\\frac{(a+1-1)}{2}\\) or \\(2a = (2a+1-1).\\)"
  },
  {
    "objectID": "posts/30_5_2024_generating_all_primes/generating_all_primes.html#wilsons-theorem-from-scratch",
    "href": "posts/30_5_2024_generating_all_primes/generating_all_primes.html#wilsons-theorem-from-scratch",
    "title": "Formula that generates all primes",
    "section": "Wilson’s theorem from scratch",
    "text": "Wilson’s theorem from scratch\nI find this one much more enjoyable as it does not require Galois theory results. Let us define the polynomial on the ring \\(Z_n\\): \\[q(x) = (x-1) (x-2) \\cdot (x - (n-1)) + 1.\\] This polynomial is trivially \\(0\\) for \\(x = 1, \\dots (n-1).\\) For \\(x=n,\\) \\(q(n) = (n-1)! + 1.\\) If \\(n\\) is a prime, then product of invertible elements is \\(-1=p-1 \\mod p.\\) Why? The product of \\(z \\times z^{-1} = 1\\) and the only elements which inverse is the element itself are the solutions of \\(z^2 = 1 \\mod p,\\) which is equivalent to \\((z-1)(z+1) = 0 \\mod p.\\) As \\(p\\) is the prime number that means the only solutions are \\(z=1\\) or \\(z=-1.\\) This means that the product of invertible elements is exactly \\(-1 \\mod p\\) as desired, when \\(p\\) is prime.\nLet us prove that if \\(n\\) is not a prime it cannot divide \\((n-1)! + 1.\\) This means we can write \\(n = a \\times b \\; \\texttt{ where } a\\geq 2,\\; b \\geq 2.\\) We can actually apply the reasoning from the first part. \\[\\texttt{QED}\\]\nThe picture source is used under Creative commons license.\n\nPython modestly optimized implementation\n\ndef generate_primes(n: int) -&gt; int:\n    \"\"\"\n    :param n: \n    :return: if n is prime, function will return n, otherwise 2\n    \"\"\"\n    # compute (n-1)! using mod n to avoid complexity\n    n_minus_1_factorial = 1\n    for i in range(2, n):\n        n_minus_1_factorial = n_minus_1_factorial * i\n        n_minus_1_factorial = n_minus_1_factorial % n\n    return 2 + ((2 * n_minus_1_factorial) % n)\n\n\ngenerate_primes(17), generate_primes(90), generate_primes(97)\n\n(17, 2, 97)"
  }
]