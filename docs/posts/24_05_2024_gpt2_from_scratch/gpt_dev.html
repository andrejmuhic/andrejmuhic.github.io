<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andrej Muhic">
<meta name="dcterms.date" content="2024-05-28">

<title>andrejmuhic.github.io - GPT and more from scratch with comments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">andrejmuhic.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">GPT and more from scratch with comments</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">NLP</div>
                <div class="quarto-category">transformers</div>
                <div class="quarto-category">deep learning</div>
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Andrej Muhic </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 28, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>All original credits to companion notebook to the <a href="https://karpathy.ai/zero-to-hero.html">Zero To Hero</a> video on GPT by Andrej Karpathy. Code was modified and heavily commented.</p>
<section id="transformer-architecture" class="level2">
<h2 class="anchored" data-anchor-id="transformer-architecture">Transformer architecture</h2>
<p>This blog post is meant as a collection of resources to facilitate deeper and easier understanding of the transformer architecture and also the main deep learning concepts. Let us start with the graph of <b>multi head causal transformer with learnable positional embedding</b> with the following setup in the full blown annotated image of the multi head attention with learnable positional encoding:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># hyperparameters</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1024</span> <span class="co"># how many independent sequences will we process in parallel?</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>block_size <span class="op">=</span> <span class="dv">128</span> <span class="co"># what is the maximum context length for predictions?</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>n_embd <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>n_head <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>n_layer <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>max_iters <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>eval_iters <span class="op">=</span> <span class="dv">200</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<details>
<summary>
Creating a graph of the model
</summary>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchview <span class="im">import</span> draw_graph</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchlens <span class="im">as</span> tl</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#device='meta' -&gt; no memory is consumed for visualization</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPT2LanguageModel()</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> model.to(device)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">#the number of parameters in the model</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sum</span>(p.numel() <span class="cf">for</span> p <span class="kw">in</span> m.parameters()) <span class="op">/</span> <span class="fl">1e6</span>, <span class="st">'M parameters'</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xb.shape)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(yb.shape)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>model_graph <span class="op">=</span> draw_graph(model, input_data<span class="op">=</span>(xb, yb), depth<span class="op">=</span><span class="dv">5</span>, expand_nested<span class="op">=</span><span class="va">True</span>, save_graph<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                         directory<span class="op">=</span><span class="bu">str</span>(Path(<span class="st">'~'</span>).expanduser()), device<span class="op">=</span><span class="st">'cuda'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model_graph)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> model_graph.visual_graph</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="bu">format</span><span class="op">=</span><span class="st">'svg'</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>graph_svg <span class="op">=</span> graph.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'svg'</span>).decode(<span class="st">'utf-8'</span>) <span class="co"># convert to binary data</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">file</span> <span class="op">=</span> <span class="bu">str</span>(Path(<span class="st">'~'</span>).expanduser()) <span class="op">+</span> <span class="st">'/multihead_transformer_with_learnable_positional_encoding.'</span> <span class="op">+</span> <span class="bu">format</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">file</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="bu">file</span>, <span class="st">'wt'</span>) <span class="im">as</span> f:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    f.write(graph_svg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="multihead_transformer_with_learnable_positional_encoding.svg" class="img-fluid figure-img"></p>
<figcaption>Multihead transformer with learnable positional encoding</figcaption>
</figure>
</div>
<p>If you can reason about the model only looking at the picture then you can skip most of the details and just dive in. The code tries to be well documented with plenty of the links to the resources that help to look at things from different perspective. If you are beginner in deep learning but have solid mathematical background I also provide collection of resources that can be helpful to get up to the speed quickly. I was using this mainly as scratchpad to note my ideas and questions over years. The view that I liked the most is transformers as GNN with additional positional encoding as I got attracted by nice symmetry, group and even categorical abstract motivation of the deep learning in general. I would like to also to point to <a href="https://www.linkedin.com/company/extrakt-ai/posts/?feedView=all">extrakt.AI</a> for one nice use case of information extraction and specifically <a href="https://www.linkedin.com/in/jan-rupnik-90790a1/">Jan Rupnik</a> and <a href="https://www.linkedin.com/in/ailab-at-jsi-3ab15937/?originalSubdomain=si">AiLab@JSI</a> for several stimulating discussions. I also recommend checking <a href="https://www.linkedin.com/company/soniox/posts/?feedView=all">Soniox</a> for interesting applications in the deeper understanding of the audio.</p>
</section>
<section id="cleaned-up-code-resources" class="level2">
<h2 class="anchored" data-anchor-id="cleaned-up-code-resources">Cleaned up code resources</h2>
<p>For cleaned up code see Karpathy:</p>
<ul>
<li><p><a href="https://github.com/karpathy/minGPT/blob/master/mingpt/model.py">minGPT</a> for python Pytorch version.</p></li>
<li><p><a href="https://github.com/karpathy/nanoGPT">nanoGPT</a></p></li>
<li><p><a href="https://github.com/karpathy/llm.c">llm.c</a> for pure C implementation.</p></li>
<li><p><a href="https://github.com/karpathy/llama2.c">llama2.c</a> for llama inference in C.</p></li>
<li><p><a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> to have some fun locally.</p></li>
<li><p><a href="https://huggingface.co/docs/transformers/en/" class="uri">https://huggingface.co/docs/transformers/en/</a></p></li>
</ul>
</section>
<section id="key-techiques-so-deep-learning-is-easier-to-use" class="level2">
<h2 class="anchored" data-anchor-id="key-techiques-so-deep-learning-is-easier-to-use">Key techiques so deep learning is easier to use</h2>
<ul>
<li>Adam/AdamW optimizer</li>
<li><a href="https://arxiv.org/abs/1706.03762">Transformers</a></li>
<li>Residual connections</li>
<li>Dropout</li>
<li>Layer/batch normalization</li>
<li>Automatic differentiation improvements</li>
<li>Polished libraries that are easy to use, <a href="https://pytorch.org/">PyTorch</a></li>
<li>Hardware acceleration optimized for the architectures</li>
</ul>
</section>
<section id="strict-run-time-named-dimension-checking" class="level2">
<h2 class="anchored" data-anchor-id="strict-run-time-named-dimension-checking">Strict run time named dimension checking</h2>
<ul>
<li><a href="https://kidger.site/thoughts/jaxtyping/" class="uri">https://kidger.site/thoughts/jaxtyping/</a></li>
<li><a href="https://docs.kidger.site/jaxtyping/api/array/" class="uri">https://docs.kidger.site/jaxtyping/api/array/</a></li>
<li><a href="https://github.com/patrick-kidger/jaxtyping" class="uri">https://github.com/patrick-kidger/jaxtyping</a></li>
<li><a href="https://github.com/agronholm/typeguard" class="uri">https://github.com/agronholm/typeguard</a></li>
</ul>
</section>
<section id="tracking-progress-of-your-runs" class="level2">
<h2 class="anchored" data-anchor-id="tracking-progress-of-your-runs">Tracking progress of your runs</h2>
<ul>
<li><a href="https://github.com/aimhubio/aim" class="uri">https://github.com/aimhubio/aim</a> free</li>
<li><a href="https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html" class="uri">https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html</a> free</li>
<li><a href="https://wandb.ai/site" class="uri">https://wandb.ai/site</a> paid</li>
</ul>
</section>
<section id="optimization-adamw-state-of-the-art" class="level2">
<h2 class="anchored" data-anchor-id="optimization-adamw-state-of-the-art">Optimization, AdamW state of the art</h2>
<ul>
<li><a href="https://www.ruder.io/optimizing-gradient-descent/#adam" class="uri">https://www.ruder.io/optimizing-gradient-descent/#adam</a></li>
<li><a href="https://iclr-blogposts.github.io/2023/blog/2023/adamw" class="uri">https://iclr-blogposts.github.io/2023/blog/2023/adamw</a> as proximal operator</li>
<li><a href="https://arxiv.org/abs/2404.04454" class="uri">https://arxiv.org/abs/2404.04454</a> Implicit Bias of AdamW: ℓ∞ Norm Constrained Optimization <code>optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)</code> Adam is just using exponential weighted average of gradient and “variance of gradients”, corrected for bias for starting at 0. AdamW adds a trick to do better incorporate L2 regularization for weight decay and is best viewed as proximal operator in my opinion.</li>
</ul>
<section id="troubles-with-regular-techniques" class="level3">
<h3 class="anchored" data-anchor-id="troubles-with-regular-techniques">Troubles with regular techniques</h3>
<ul>
<li>Memory constraints even for Adam(W) we need to store two additional vectors thus we 3x our memory requirements.</li>
<li>Back stepping is not feasible for deep learning, too costly to store harder to parallelize!</li>
<li><a href="https://en.wikipedia.org/wiki/Limited-memory_BFGS" class="uri">https://en.wikipedia.org/wiki/Limited-memory_BFGS</a> approximates inverse of Hessian implicitly and even this is too costly.</li>
<li><a href="https://en.wikipedia.org/wiki/Wolfe_conditions" class="uri">https://en.wikipedia.org/wiki/Wolfe_conditions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Backtracking_line_search" class="uri">https://en.wikipedia.org/wiki/Backtracking_line_search</a> more advanced step size</li>
</ul>
</section>
</section>
<section id="visualizing-the-network" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-the-network">Visualizing the network</h2>
<ul>
<li>My personal favourite: <a href="https://github.com/mert-kurttutan/torchview" class="uri">https://github.com/mert-kurttutan/torchview</a> nicer graph, device=‘meta’ is buggy sometimes, use cuda or cpu.</li>
<li>Honourable mentions: <a href="https://github.com/szagoruyko/pytorchviz" class="uri">https://github.com/szagoruyko/pytorchviz</a></li>
</ul>
</section>
<section id="activations" class="level2">
<h2 class="anchored" data-anchor-id="activations">Activations</h2>
<ul>
<li><a href="https://www.ai-contentlab.com/2023/03/swishglu-activation-function.html" class="uri">https://www.ai-contentlab.com/2023/03/swishglu-activation-function.html</a></li>
<li><a href="https://pytorch.org/docs/stable/generated/torch.nn.SiLU.html" class="uri">https://pytorch.org/docs/stable/generated/torch.nn.SiLU.html</a></li>
</ul>
</section>
<section id="useful-tricks" class="level2">
<h2 class="anchored" data-anchor-id="useful-tricks">Useful tricks</h2>
<section id="einsum-formulas-for-humans" class="level3">
<h3 class="anchored" data-anchor-id="einsum-formulas-for-humans">Einsum formulas for humans</h3>
<ul>
<li><a href="https://einops.rocks/api/einsum" class="uri">https://einops.rocks/api/einsum</a></li>
</ul>
</section>
<section id="broadcasting" class="level3">
<h3 class="anchored" data-anchor-id="broadcasting">Broadcasting</h3>
<ul>
<li><a href="https://numpy.org/doc/stable/user/basics.broadcasting.html" class="uri">https://numpy.org/doc/stable/user/basics.broadcasting.html</a> My advice would be if you are not sure do manual broadcasting and test.</li>
<li>Strictly test dimenstions with something like jaxtyping</li>
</ul>
</section>
<section id="sanity-checks-and-data" class="level3">
<h3 class="anchored" data-anchor-id="sanity-checks-and-data">Sanity checks and data</h3>
<ul>
<li>Inspect your data before you start training</li>
<li>Overift on small piece of data using simplest possible model before trying to do something fancy</li>
<li>Getting better and more data will bring larger improvements than using superior model</li>
</ul>
</section>
</section>
<section id="nlp-specific-info" class="level2">
<h2 class="anchored" data-anchor-id="nlp-specific-info">NLP specific info</h2>
<section id="tokenization" class="level3">
<h3 class="anchored" data-anchor-id="tokenization">Tokenization</h3>
<ul>
<li>In practice one would use something like <a href="https://github.com/karpathy/minbpe">Byte Pair Encoding</a> or <a href="https://huggingface.co/docs/transformers/en/tokenizer_summary">WordPiece, SentencePiece</a> ### Attention and geometric deep learning</li>
<li>Attention: <a href="https://magazine.sebastianraschka.com/p/understanding-and-coding-self-attention" class="uri">https://magazine.sebastianraschka.com/p/understanding-and-coding-self-attention</a></li>
<li><a href="https://arxiv.org/abs/2301.08210">GNN</a> and <a href="https://geometricdeeplearning.com/lectures/">Geometric Deep Learning</a></li>
<li>Geometric Deep learning excites me as mathematician as it is a very nice way of infusing domain priors, symmetry, geometry of the problem</li>
</ul>
</section>
<section id="alternative-architectures-and-improvements" class="level3">
<h3 class="anchored" data-anchor-id="alternative-architectures-and-improvements">Alternative architectures and improvements</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=e7TFEgq5xiY">Mamba</a></li>
<li><a href="https://www.oxen.ai/blog/mamba-linear-time-sequence-modeling-with-selective-state-spaces-arxiv-dives">Mamba with more details</a></li>
<li><a href="https://huggingface.co/docs/text-generation-inference/en/conceptual/flash_attention">Flash attention, hardware optimized attention</a></li>
</ul>
</section>
<section id="embeddings" class="level3">
<h3 class="anchored" data-anchor-id="embeddings">Embeddings</h3>
<ul>
<li><a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">Classical not relative but fixed embedding</a></li>
<li><a href="https://afterhoursresearch.hashnode.dev/rope-rotary-positional-embedding">RoPE - Rotary Positional Embedding</a></li>
<li><a href="https://blog.eleuther.ai/rotary-embeddings/">Rotary embeddings</a></li>
</ul>
</section>
<section id="various-sources" class="level3">
<h3 class="anchored" data-anchor-id="various-sources">Various sources</h3>
<ul>
<li>How to influence bias of probabilities, <a href="https://en.wikipedia.org/wiki/LogSumExp">temperature using LogSumExp</a> What happens when you divide logits by positivee <span class="math inline">\(\texttt{Temp}\)</span> and then do <span class="math inline">\(\texttt{softmax}.\)</span> Temperature close to 0 gives us max in limit, one hot, <span class="math inline">\(\texttt{Temp}\)</span> &gt;&gt; 1 in limit is random sampling.</li>
<li><a href="https://ai.plainenglish.io/understanding-llama2-kv-cache-grouped-query-attention-rotary-embedding-and-more-c17e5f49a6d7">Understanding llama2</a></li>
<li><a href="https://agustinus.kristia.de/techblog/2016/12/21/forward-reverse-kl/">Forward and reverse KL divergence</a></li>
</ul>
</section>
</section>
<section id="stricter-typing" class="level2">
<h2 class="anchored" data-anchor-id="stricter-typing">Stricter typing</h2>
<div id="cell-3" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-05-27T19:11:30.229707Z&quot;,&quot;start_time&quot;:&quot;2024-05-27T19:11:28.486745Z&quot;}" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us do some stricter typing</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config Completer.use_jedi <span class="op">=</span> <span class="va">False</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># from sklearn.model_selection import train_test_split</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> typing</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> TYPE_CHECKING, Any, Optional</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Strict run time dimension checking</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># https://kidger.site/thoughts/jaxtyping/</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># https://docs.kidger.site/jaxtyping/api/array/</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/patrick-kidger/jaxtyping</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/agronholm/typeguard</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracking the progress: </span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">#                        https://github.com/aimhubio/aim</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">#                        https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">#                        https://wandb.ai/site</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Something on order of distributions in cross entropy and KL</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># https://agustinus.kristia.de/techblog/2016/12/21/forward-reverse-kl/</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualizing the network</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/szagoruyko/pytorchviz</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/mert-kurttutan/torchview nicer graph</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimization, AdamW state of the art</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co"># https://www.ruder.io/optimizing-gradient-descent/#adam</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># https://iclr-blogposts.github.io/2023/blog/2023/adamw/ as proximal operator</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="co"># https://arxiv.org/abs/2404.04454 Implicit Bias of AdamW: ℓ∞ Norm Constrained Optimization</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="co"># optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co"># exponential weighted average of gradient and "variance of gradients", corrected for bias for starting at 0 </span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"># +  a trick to do better than L2 for decay rate</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Back stepping</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Not feasible for deep learning, too costly to store harder to parallelize!</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Limited-memory_BFGS approximates inverse of Hessian implicitly and even this is too costly</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Wolfe_conditions</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Backtracking_line_search more advanced step size</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Activations</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co"># https://www.ai-contentlab.com/2023/03/swishglu-activation-function.html</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co"># https://pytorch.org/docs/stable/generated/torch.nn.SiLU.html</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Einsum formulas for human, thanks for the hint guys!</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="co"># https://einops.rocks/api/einsum/</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Broadcasting</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="co"># https://numpy.org/doc/stable/user/basics.broadcasting.html My advice would be if you are not sure do manual broadcasting and test.</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Strictly test dimenstions with something like jaxtyping</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="co"># key enabling techiques that made deep learning more easy to work with</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="co"># - adam/adamw optimizer</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="co"># - residual connections</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="co"># - dropout</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span class="co"># - layer/batch normalization</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a><span class="co"># - automatic differentiation</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jaxtyping <span class="im">import</span> Float, Int64</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>Array: typing.TypeAlias <span class="op">=</span> torch.Tensor</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>Long: typing.TypeAlias <span class="op">=</span> Int64</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="loading-the-data" class="level2">
<h2 class="anchored" data-anchor-id="loading-the-data">Loading the data</h2>
<div id="cell-5" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:12.945313Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:12.169198Z&quot;}" data-outputid="ccc60f0c-fd78-4dbe-8598-0512d1036aad" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We always start with a dataset to train on. Let's download the tiny shakespeare dataset</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> Path(<span class="st">'~'</span>).expanduser() <span class="op">/</span> <span class="ss">f'.cache/input.txt'</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> save_path.exists():</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>wget https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>karpathy<span class="op">/</span>char<span class="op">-</span>rnn<span class="op">/</span>master<span class="op">/</span>data<span class="op">/</span>tinyshakespeare<span class="op">/</span><span class="bu">input</span>.txt <span class="op">-</span>O {save_path}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="inspecting-the-data" class="level2">
<h2 class="anchored" data-anchor-id="inspecting-the-data">Inspecting the data</h2>
<div id="cell-7" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:14.363452Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:14.356350Z&quot;}" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read it in to inspect it</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> save_path.<span class="bu">open</span>(<span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    text <span class="op">=</span> f.read()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-8" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:15.359789Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:15.353664Z&quot;}" data-outputid="ed819dd0-72e5-40a6-d2ed-928ff73bfda6" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"length of dataset in characters: "</span>, <span class="bu">len</span>(text))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>length of dataset in characters:  1115394</code></pre>
</div>
</div>
<div id="cell-9" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:15.872090Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:15.867851Z&quot;}" data-outputid="25ca7adc-b8c0-42d1-b08c-e0863c5c314e" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let's look at the first 1000 characters</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(text[:<span class="dv">1000</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>First Citizen:
Before we proceed any further, hear me speak.

All:
Speak, speak.

First Citizen:
You are all resolved rather to die than to famish?

All:
Resolved. resolved.

First Citizen:
First, you know Caius Marcius is chief enemy to the people.

All:
We know't, we know't.

First Citizen:
Let us kill him, and we'll have corn at our own price.
Is't a verdict?

All:
No more talking on't; let it be done: away, away!

Second Citizen:
One word, good citizens.

First Citizen:
We are accounted poor citizens, the patricians good.
What authority surfeits on would relieve us: if they
would yield us but the superfluity, while it were
wholesome, we might guess they relieved us humanely;
but they think we are too dear: the leanness that
afflicts us, the object of our misery, is as an
inventory to particularise their abundance; our
sufferance is a gain to them Let us revenge this with
our pikes, ere we become rakes: for the gods know I
speak this in hunger for bread, not in thirst for revenge.

</code></pre>
</div>
</div>
<section id="unique-characters-as-tokens-65-vocabulary-size" class="level3">
<h3 class="anchored" data-anchor-id="unique-characters-as-tokens-65-vocabulary-size">Unique characters as tokens, 65 vocabulary size</h3>
<div id="cell-11" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:16.621405Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:16.602273Z&quot;}" data-outputid="f34e94a9-5b44-4cf3-885b-986731929109" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># here are all the unique characters that occur in this text</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>chars: <span class="bu">list</span>[<span class="bu">str</span>] <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">''</span>.join(chars))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(vocab_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
 !$&amp;',-.3:;?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
65</code></pre>
</div>
</div>
</section>
<section id="mapping-from-characters-to-integers" class="level3">
<h3 class="anchored" data-anchor-id="mapping-from-characters-to-integers">Mapping from characters to integers</h3>
<div id="cell-13" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:20.037680Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:20.028295Z&quot;}" data-outputid="86fcc21c-2cf7-40d9-cd7b-b5a253da4459" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a mapping from characters to integers</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>stoi: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">int</span>] <span class="op">=</span> {ch: i <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars)}</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>itos: <span class="bu">dict</span>[<span class="bu">int</span>, <span class="bu">str</span>] <span class="op">=</span> {i: ch <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars)}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s]  <span class="co"># encoder: take a string, output a list of integers</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l])  <span class="co"># decoder: take a list of integers, output a string</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># In practice one would use something like [Byte Pair Encoding](https://github.com/karpathy/minbpe) or [WordPiece, SentencePiece](https://huggingface.co/docs/transformers/en/tokenizer_summary)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(encode(<span class="st">"hii there"</span>))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode(encode(<span class="st">"hii there"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[46, 47, 47, 1, 58, 46, 43, 56, 43]
hii there</code></pre>
</div>
</div>
<div id="cell-14" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:21.266498Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:21.071632Z&quot;}" data-outputid="db7297cc-36a9-4fae-e941-e7bb9e0e91d1" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let's now encode the entire text dataset and store it into a torch.Tensor</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch  <span class="co"># we use PyTorch: https://pytorch.org</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.int64)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data.shape, data.dtype)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[:<span class="dv">1000</span>])  <span class="co"># the 1000 characters we looked at earier will to the GPT look like this</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([1115394]) torch.int64
tensor([18, 47, 56, 57, 58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 14, 43, 44,
        53, 56, 43,  1, 61, 43,  1, 54, 56, 53, 41, 43, 43, 42,  1, 39, 52, 63,
         1, 44, 59, 56, 58, 46, 43, 56,  6,  1, 46, 43, 39, 56,  1, 51, 43,  1,
        57, 54, 43, 39, 49,  8,  0,  0, 13, 50, 50, 10,  0, 31, 54, 43, 39, 49,
         6,  1, 57, 54, 43, 39, 49,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47,
        58, 47, 64, 43, 52, 10,  0, 37, 53, 59,  1, 39, 56, 43,  1, 39, 50, 50,
         1, 56, 43, 57, 53, 50, 60, 43, 42,  1, 56, 39, 58, 46, 43, 56,  1, 58,
        53,  1, 42, 47, 43,  1, 58, 46, 39, 52,  1, 58, 53,  1, 44, 39, 51, 47,
        57, 46, 12,  0,  0, 13, 50, 50, 10,  0, 30, 43, 57, 53, 50, 60, 43, 42,
         8,  1, 56, 43, 57, 53, 50, 60, 43, 42,  8,  0,  0, 18, 47, 56, 57, 58,
         1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 18, 47, 56, 57, 58,  6,  1, 63,
        53, 59,  1, 49, 52, 53, 61,  1, 15, 39, 47, 59, 57,  1, 25, 39, 56, 41,
        47, 59, 57,  1, 47, 57,  1, 41, 46, 47, 43, 44,  1, 43, 52, 43, 51, 63,
         1, 58, 53,  1, 58, 46, 43,  1, 54, 43, 53, 54, 50, 43,  8,  0,  0, 13,
        50, 50, 10,  0, 35, 43,  1, 49, 52, 53, 61,  5, 58,  6,  1, 61, 43,  1,
        49, 52, 53, 61,  5, 58,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47, 58,
        47, 64, 43, 52, 10,  0, 24, 43, 58,  1, 59, 57,  1, 49, 47, 50, 50,  1,
        46, 47, 51,  6,  1, 39, 52, 42,  1, 61, 43,  5, 50, 50,  1, 46, 39, 60,
        43,  1, 41, 53, 56, 52,  1, 39, 58,  1, 53, 59, 56,  1, 53, 61, 52,  1,
        54, 56, 47, 41, 43,  8,  0, 21, 57,  5, 58,  1, 39,  1, 60, 43, 56, 42,
        47, 41, 58, 12,  0,  0, 13, 50, 50, 10,  0, 26, 53,  1, 51, 53, 56, 43,
         1, 58, 39, 50, 49, 47, 52, 45,  1, 53, 52,  5, 58, 11,  1, 50, 43, 58,
         1, 47, 58,  1, 40, 43,  1, 42, 53, 52, 43, 10,  1, 39, 61, 39, 63,  6,
         1, 39, 61, 39, 63,  2,  0,  0, 31, 43, 41, 53, 52, 42,  1, 15, 47, 58,
        47, 64, 43, 52, 10,  0, 27, 52, 43,  1, 61, 53, 56, 42,  6,  1, 45, 53,
        53, 42,  1, 41, 47, 58, 47, 64, 43, 52, 57,  8,  0,  0, 18, 47, 56, 57,
        58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 35, 43,  1, 39, 56, 43,  1,
        39, 41, 41, 53, 59, 52, 58, 43, 42,  1, 54, 53, 53, 56,  1, 41, 47, 58,
        47, 64, 43, 52, 57,  6,  1, 58, 46, 43,  1, 54, 39, 58, 56, 47, 41, 47,
        39, 52, 57,  1, 45, 53, 53, 42,  8,  0, 35, 46, 39, 58,  1, 39, 59, 58,
        46, 53, 56, 47, 58, 63,  1, 57, 59, 56, 44, 43, 47, 58, 57,  1, 53, 52,
         1, 61, 53, 59, 50, 42,  1, 56, 43, 50, 47, 43, 60, 43,  1, 59, 57, 10,
         1, 47, 44,  1, 58, 46, 43, 63,  0, 61, 53, 59, 50, 42,  1, 63, 47, 43,
        50, 42,  1, 59, 57,  1, 40, 59, 58,  1, 58, 46, 43,  1, 57, 59, 54, 43,
        56, 44, 50, 59, 47, 58, 63,  6,  1, 61, 46, 47, 50, 43,  1, 47, 58,  1,
        61, 43, 56, 43,  0, 61, 46, 53, 50, 43, 57, 53, 51, 43,  6,  1, 61, 43,
         1, 51, 47, 45, 46, 58,  1, 45, 59, 43, 57, 57,  1, 58, 46, 43, 63,  1,
        56, 43, 50, 47, 43, 60, 43, 42,  1, 59, 57,  1, 46, 59, 51, 39, 52, 43,
        50, 63, 11,  0, 40, 59, 58,  1, 58, 46, 43, 63,  1, 58, 46, 47, 52, 49,
         1, 61, 43,  1, 39, 56, 43,  1, 58, 53, 53,  1, 42, 43, 39, 56, 10,  1,
        58, 46, 43,  1, 50, 43, 39, 52, 52, 43, 57, 57,  1, 58, 46, 39, 58,  0,
        39, 44, 44, 50, 47, 41, 58, 57,  1, 59, 57,  6,  1, 58, 46, 43,  1, 53,
        40, 48, 43, 41, 58,  1, 53, 44,  1, 53, 59, 56,  1, 51, 47, 57, 43, 56,
        63,  6,  1, 47, 57,  1, 39, 57,  1, 39, 52,  0, 47, 52, 60, 43, 52, 58,
        53, 56, 63,  1, 58, 53,  1, 54, 39, 56, 58, 47, 41, 59, 50, 39, 56, 47,
        57, 43,  1, 58, 46, 43, 47, 56,  1, 39, 40, 59, 52, 42, 39, 52, 41, 43,
        11,  1, 53, 59, 56,  0, 57, 59, 44, 44, 43, 56, 39, 52, 41, 43,  1, 47,
        57,  1, 39,  1, 45, 39, 47, 52,  1, 58, 53,  1, 58, 46, 43, 51,  1, 24,
        43, 58,  1, 59, 57,  1, 56, 43, 60, 43, 52, 45, 43,  1, 58, 46, 47, 57,
         1, 61, 47, 58, 46,  0, 53, 59, 56,  1, 54, 47, 49, 43, 57,  6,  1, 43,
        56, 43,  1, 61, 43,  1, 40, 43, 41, 53, 51, 43,  1, 56, 39, 49, 43, 57,
        10,  1, 44, 53, 56,  1, 58, 46, 43,  1, 45, 53, 42, 57,  1, 49, 52, 53,
        61,  1, 21,  0, 57, 54, 43, 39, 49,  1, 58, 46, 47, 57,  1, 47, 52,  1,
        46, 59, 52, 45, 43, 56,  1, 44, 53, 56,  1, 40, 56, 43, 39, 42,  6,  1,
        52, 53, 58,  1, 47, 52,  1, 58, 46, 47, 56, 57, 58,  1, 44, 53, 56,  1,
        56, 43, 60, 43, 52, 45, 43,  8,  0,  0])</code></pre>
</div>
</div>
</section>
<section id="trainvalidation-split" class="level3">
<h3 class="anchored" data-anchor-id="trainvalidation-split">Train/validation split</h3>
<div id="cell-16" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:21.893448Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:21.888138Z&quot;}" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's now split up the data into train and validation sets</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span> <span class="op">*</span> <span class="bu">len</span>(data))  <span class="co"># first 90% will be train, rest val</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>val_data <span class="op">=</span> data[n:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-17" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:22.749280Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:22.736514Z&quot;}" data-outputid="bf23c586-1d33-4af1-b63d-ce6f90b0a528" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>block_size <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># First block and the target</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>train_data[:block_size <span class="op">+</span> <span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>tensor([18, 47, 56, 57, 58,  1, 15, 47, 58])</code></pre>
</div>
</div>
<div id="cell-18" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:23.346539Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:23.337420Z&quot;}" data-outputid="588663aa-1de5-4ef7-aba0-4a96fe828353" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is what we want to learn for max_context_size = block_size</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"># It is important that we train also for shorter sequences than block_size</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># When creating batches in practice we could need padding token and if pad left or right!</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Also how to shuffle if we need to if data does not fit in memory: https://blog.janestreet.com/how-to-shuffle-a-big-dataset/</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> train_data[:block_size]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> train_data[<span class="dv">1</span>:block_size <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size):</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    context <span class="op">=</span> x[:t <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> y[t]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>when input is tensor([18]) the target: 47
when input is tensor([18, 47]) the target: 56
when input is tensor([18, 47, 56]) the target: 57
when input is tensor([18, 47, 56, 57]) the target: 58
when input is tensor([18, 47, 56, 57, 58]) the target: 1
when input is tensor([18, 47, 56, 57, 58,  1]) the target: 15
when input is tensor([18, 47, 56, 57, 58,  1, 15]) the target: 47
when input is tensor([18, 47, 56, 57, 58,  1, 15, 47]) the target: 58</code></pre>
</div>
</div>
</section>
<section id="batch-generation" class="level3">
<h3 class="anchored" data-anchor-id="batch-generation">Batch generation</h3>
<div id="cell-20" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:24.199559Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:24.160058Z&quot;}" data-outputid="4ea8e8a0-443c-49bb-b3bf-ba36e1712999" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">4</span>  <span class="co"># how many independent sequences will we process in parallel?</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>block_size <span class="op">=</span> <span class="dv">8</span>  <span class="co"># what is the maximum context length for predictions?</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_batch(split_kind: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Int64[Array, <span class="st">"n_batches block_size"</span>], Int64[Array, <span class="st">"n_batches block_size"</span>]]:</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># generate a small batch of data of inputs x and targets y</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split_kind <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Random starting indices of blocks, notice that blocks can overlap</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># To do something like this for real: </span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> torch.stack([data[i:i <span class="op">+</span> block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> torch.stack([data[i <span class="op">+</span> <span class="dv">1</span>:i <span class="op">+</span> block_size <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x, y</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'inputs:'</span>)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xb.shape)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xb)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'targets:'</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(yb.shape)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(yb)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'----'</span>)</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(batch_size):  <span class="co"># batch dimension</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size):  <span class="co"># time dimension</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        context <span class="op">=</span> xb[b, :t <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        target <span class="op">=</span> yb[b, t]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>inputs:
torch.Size([4, 8])
tensor([[24, 43, 58,  5, 57,  1, 46, 43],
        [44, 53, 56,  1, 58, 46, 39, 58],
        [52, 58,  1, 58, 46, 39, 58,  1],
        [25, 17, 27, 10,  0, 21,  1, 54]])
targets:
torch.Size([4, 8])
tensor([[43, 58,  5, 57,  1, 46, 43, 39],
        [53, 56,  1, 58, 46, 39, 58,  1],
        [58,  1, 58, 46, 39, 58,  1, 46],
        [17, 27, 10,  0, 21,  1, 54, 39]])
----
when input is [24] the target: 43
when input is [24, 43] the target: 58
when input is [24, 43, 58] the target: 5
when input is [24, 43, 58, 5] the target: 57
when input is [24, 43, 58, 5, 57] the target: 1
when input is [24, 43, 58, 5, 57, 1] the target: 46
when input is [24, 43, 58, 5, 57, 1, 46] the target: 43
when input is [24, 43, 58, 5, 57, 1, 46, 43] the target: 39
when input is [44] the target: 53
when input is [44, 53] the target: 56
when input is [44, 53, 56] the target: 1
when input is [44, 53, 56, 1] the target: 58
when input is [44, 53, 56, 1, 58] the target: 46
when input is [44, 53, 56, 1, 58, 46] the target: 39
when input is [44, 53, 56, 1, 58, 46, 39] the target: 58
when input is [44, 53, 56, 1, 58, 46, 39, 58] the target: 1
when input is [52] the target: 58
when input is [52, 58] the target: 1
when input is [52, 58, 1] the target: 58
when input is [52, 58, 1, 58] the target: 46
when input is [52, 58, 1, 58, 46] the target: 39
when input is [52, 58, 1, 58, 46, 39] the target: 58
when input is [52, 58, 1, 58, 46, 39, 58] the target: 1
when input is [52, 58, 1, 58, 46, 39, 58, 1] the target: 46
when input is [25] the target: 17
when input is [25, 17] the target: 27
when input is [25, 17, 27] the target: 10
when input is [25, 17, 27, 10] the target: 0
when input is [25, 17, 27, 10, 0] the target: 21
when input is [25, 17, 27, 10, 0, 21] the target: 1
when input is [25, 17, 27, 10, 0, 21, 1] the target: 54
when input is [25, 17, 27, 10, 0, 21, 1, 54] the target: 39</code></pre>
</div>
</div>
<div id="cell-21" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:24.800094Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:24.795285Z&quot;}" data-outputid="a650f8dc-da81-400b-bc59-0a595487fdb9" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xb)  <span class="co"># our input to the transformer</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[24, 43, 58,  5, 57,  1, 46, 43],
        [44, 53, 56,  1, 58, 46, 39, 58],
        [52, 58,  1, 58, 46, 39, 58,  1],
        [25, 17, 27, 10,  0, 21,  1, 54]])</code></pre>
</div>
</div>
</section>
</section>
<section id="bigram-language-model" class="level2">
<h2 class="anchored" data-anchor-id="bigram-language-model">Bigram language model</h2>
<p>What is the most likely next token given the current token? We are targeting the probability or logit of the next token, given the current token.</p>
<div id="cell-23" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T21:03:25.254204Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T21:03:25.212434Z&quot;}" data-outputid="5de90b1b-4603-428a-f571-fe4bd3c45436" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BigramLanguageModel(nn.Module):</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, vocab_size: <span class="bu">int</span>):</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># each token directly reads off the logits for the next token from a lookup table</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, vocab_size)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx: Long[torch.Tensor, <span class="st">"batch_dim context_dim"</span>],</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>                targets: Optional[Long[torch.Tensor, <span class="st">"batch_dim context_dim"</span>]] <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># idx and targets are both (B,T) tensor of integers</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        logits: Long[torch.Tensor, <span class="st">"batch_dim context_dim latent_dim"</span>] <span class="op">=</span> <span class="va">self</span>.token_embedding_table(</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>            idx)  <span class="co"># (B,T,C=vocab_size)</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> logits, <span class="va">None</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Note that here strictly speaking this does not fix batch size explicitly to B</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>            B, T, C <span class="op">=</span> logits.shape  <span class="co"># (B,T,C=vocab_size)</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Just a hack to avoid transposing, cross_entropy expects B x C x T in batched mode</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This converts into non batched mode</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>            logits: Long[torch.Tensor, <span class="st">"batch_dim*context_dim latent_dim"</span>] <span class="op">=</span> logits.view(B <span class="op">*</span> T, C)</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>            targets: Long[torch.Tensor, <span class="st">"batch_dim*context_dim"</span>] <span class="op">=</span> targets.view(B <span class="op">*</span> T)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># https://agustinus.kristia.de/techblog/2016/12/21/forward-reverse-kl/</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>            loss: Float[torch.Tensor, <span class="st">""</span>] <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> logits, loss</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx: Long[torch.Tensor, <span class="st">"batch_dim context_dim"</span>], max_new_tokens: <span class="bu">int</span>):</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># idx is (B, T) array of indices in the current context</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get the predictions</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx)</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>            <span class="co"># focus only on the last time step</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :]  <span class="co"># becomes (B, vocab_size)</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># apply softmax to get probabilities</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># (B, vocab_size)</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># sample from the distribution</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (B, 1)</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># append sampled index to the running sequence</span></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (B, T+1)</span></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>            <span class="co"># What can go wrong here? and it is not handled at all</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idx</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> BigramLanguageModel(vocab_size)</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>logits, loss <span class="op">=</span> m(xb, yb)</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(logits.shape)</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loss)</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loss.shape)</span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode(m.generate(idx<span class="op">=</span>torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">100</span>)[<span class="dv">0</span>].tolist()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([32, 65])
tensor(4.8786, grad_fn=&lt;NllLossBackward0&gt;)
torch.Size([])

Sr?qP-QWktXoL&amp;jLDJgOLVz'RIoDqHdhsV&amp;vLLxatjscMpwLERSPyao.qfzs$Ys$zF-w,;eEkzxjgCKFChs!iWW.ObzDnxA Ms$3</code></pre>
</div>
</div>
<div id="cell-24" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">### Optimization using AdamW and cross entropy</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-25" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:30.056752Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:30.049343Z&quot;}" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a PyTorch optimizer</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.AdamW(m.parameters(), lr<span class="op">=</span><span class="fl">1e-3</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># weighted average of mean and "variance" of gradients +  a trick</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Not feasible for deep learning, too costly to store harder to parallelize!</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Limited-memory_BFGS approximates inverse of Hessian implicitly and even this is too costly</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Wolfe_conditions</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co"># https://en.wikipedia.org/wiki/Backtracking_line_search more advanced step size</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-26" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:31.157783Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:30.847995Z&quot;}" data-outputid="42ded55c-2983-4d91-c528-675b2edfa849" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> steps <span class="kw">in</span> <span class="bu">range</span>(n_steps):  <span class="co"># increase number of steps for good results...</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sample a batch of data</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># evaluate the loss</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    logits, loss <span class="op">=</span> m(xb, yb)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    loss.backward()</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    optimizer.step()</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loss.item())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>3.7218432426452637</code></pre>
</div>
</div>
<div id="cell-27" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:31.993194Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:31.909969Z&quot;}" data-outputid="0ad6f9d2-ad58-4498-a5f8-6f31407bb18b" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode(m.generate(idx<span class="op">=</span>torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">500</span>)[<span class="dv">0</span>].tolist()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
olylvLLko'TMyatyIoconxad.?-tNSqYPsx&amp;bF.oiR;BD$dZBMZv'K f bRSmIKptRPly:AUC&amp;$zLK,qUEy&amp;Ay;ZxjKVhmrdagC-bTop-QJe.H?x
JGF&amp;pwst-P sti.hlEsu;w:w a BG:tLhMk,epdhlay'sVzLq--ERwXUzDnq-bn czXxxI&amp;V&amp;Pynnl,s,Ioto!uvixwC-IJXElrgm C-.bcoCPJ
IMphsevhO AL!-K:AIkpre,
rPHEJUzV;P?uN3b?ohoRiBUENoV3B&amp;jumNL;Aik,
xf -IEKROn JSyYWW?n 'ay;:weO'AqVzPyoiBL? seAX3Dot,iy.xyIcf r!!ul-Koi:x pZrAQly'v'a;vEzN
BwowKo'MBqF$PPFb
CjYX3beT,lZ qdda!wfgmJP
DUfNXmnQU mvcv?nlnQF$JUAAywNocd  bGSPyAlprNeQnq-GRSVUP.Ja!IBoDqfI&amp;xJM AXEHV&amp;DKvRS</code></pre>
</div>
</div>
</section>
<section id="the-mathematical-formulation-of-causal-self-attention" class="level2">
<h2 class="anchored" data-anchor-id="the-mathematical-formulation-of-causal-self-attention">The mathematical formulation of (causal) self-attention</h2>
<div id="cell-29" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:34.287696Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:34.274350Z&quot;}" data-outputid="d981f6d4-ac08-4ec2-8284-82f5fa1e0815" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># toy example illustrating how matrix multiplication can be used for a "weighted aggregation"</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Causal attention does not take into account future information</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.tril(torch.ones(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> a <span class="op">/</span> torch.<span class="bu">sum</span>(a, <span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.randint(<span class="dv">0</span>, <span class="dv">10</span>, (<span class="dv">3</span>, <span class="dv">2</span>)).<span class="bu">float</span>()</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">@</span> b</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'a='</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'b='</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'c='</span>)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>a=
tensor([[1.0000, 0.0000, 0.0000],
        [0.5000, 0.5000, 0.0000],
        [0.3333, 0.3333, 0.3333]])
--
b=
tensor([[2., 7.],
        [6., 4.],
        [6., 5.]])
--
c=
tensor([[2.0000, 7.0000],
        [4.0000, 5.5000],
        [4.6667, 5.3333]])</code></pre>
</div>
</div>
<div id="cell-30" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:35.757818Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:35.750440Z&quot;}" data-outputid="8bf3ff5f-565e-48b8-de8e-7272706c8e12" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># consider the following toy example:</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>B, T, C <span class="op">=</span> <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">2</span>  <span class="co"># batch, time, channels</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(B, T, C)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>x.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>torch.Size([4, 8, 2])</code></pre>
</div>
</div>
<section id="manual-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="manual-aggregation">Manual aggregation</h3>
<div id="cell-32" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:37.597716Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:37.589303Z&quot;}" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We want $x[b,t] = mean_{i&lt;=t} x[b,i]$</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>xbow <span class="op">=</span> torch.zeros((B, T, C))</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T):</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        xprev <span class="op">=</span> x[b, :t <span class="op">+</span> <span class="dv">1</span>]  <span class="co"># (t,C)</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        xbow[b, t] <span class="op">=</span> torch.mean(xprev, <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="matrix-multiply-for-weighted-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiply-for-weighted-aggregation">Matrix multiply for weighted aggregation</h3>
<div id="cell-34" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:38.549976Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:38.543326Z&quot;}" data-outputid="eaf6ab61-dff1-4bb7-e623-47f692bad5f9" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># version 2: using matrix multiply for a weighted aggregation</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> wei <span class="op">/</span> wei.<span class="bu">sum</span>(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>xbow2 <span class="op">=</span> wei <span class="op">@</span> x  <span class="co"># (B, T, T) @ (B, T, C) ----&gt; (B, T, C)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Numerical instability and float32 only, need to set lower relative accuracy</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>torch.allclose(xbow, xbow2, <span class="fl">1e-4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>True</code></pre>
</div>
</div>
<div id="cell-35" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">### Softmax for weighted aggregation</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-36" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:39.799510Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:39.789420Z&quot;}" data-outputid="080b500d-8110-4602-fcef-7d6f2ebfc6bc" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># version 3: use Softmax</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> torch.zeros((T, T))</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># This seems strange at first glance but exp(-inf) = 0 and it is well defined, otherwise training would get broken constantly</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>xbow3 <span class="op">=</span> wei <span class="op">@</span> x</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Numerical instability and float32 only, need to set lower relative accuracy</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>torch.allclose(xbow, xbow3, <span class="fl">1e-4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>True</code></pre>
</div>
</div>
</section>
<section id="self-attention" class="level3">
<h3 class="anchored" data-anchor-id="self-attention">Self attention</h3>
<p><span class="math display">\[\texttt{Attention}(Q, K, V) = \texttt{softmax}(\frac{QK^T}{\sqrt{d_k}})V,\]</span> where <span class="math inline">\(\sqrt{d_k}\)</span> is the dimension of the key vector <span class="math inline">\(k\)</span> and query vector <span class="math inline">\(q\)</span>. The causal version can only take into account current and past tokens se we need to mask all future token inputs so that they not influence the prediction of the next token. This can be accomplished by triangular mask.</p>
</section>
<section id="multi-head-attention" class="level3">
<h3 class="anchored" data-anchor-id="multi-head-attention">Multi head attention</h3>
<p><span class="math display">\[\texttt{MultiHead}(Q, K, V) = \texttt{Concat}(\texttt{head}_1, ..., \texttt{head}_h)W^O,\]</span> where <span class="math display">\[\texttt{head}_i = \texttt{Attention}(Q W^Q_i, K W^K_i, V W^V_i).\]</span></p>
<p>Modifed from <a href="https://blmoistawinde.github.io/ml_equations_latex/">ML equations in latex</a>. As a note, the vectors are rows and not columns like in Matlab.</p>
<div id="cell-38" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:40.749584Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:40.734139Z&quot;}" data-outputid="07b587dd-a91c-4bb0-d7f1-e247cd5dacb5" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># version 4: self-attention!</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>B, T, C <span class="op">=</span> <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">32</span>  <span class="co"># batch, time, channels</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(B, T, C)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co"># let's see a single Head perform self-attention</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>head_size <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> key(x)  <span class="co"># (B, T, 16)</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> query(x)  <span class="co"># (B, T, 16)</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)  <span class="co"># (B, T, 16) @ (B, 16, T) ---&gt; (B, T, T)</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="co"># wei = torch.zeros((T,T))</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Full matrix multiplication is faster, just block what we do not need</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> value(x)</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> wei <span class="op">@</span> v</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a><span class="co"># out = wei @ x</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>out.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>torch.Size([4, 8, 16])</code></pre>
</div>
</div>
<div id="cell-40" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:44.061674Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:44.053844Z&quot;}" data-outputid="6d2c569b-7922-451f-9934-0fc564678d17" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>wei[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>tensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.1574, 0.8426, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.2088, 0.1646, 0.6266, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.5792, 0.1187, 0.1889, 0.1131, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.0294, 0.1052, 0.0469, 0.0276, 0.7909, 0.0000, 0.0000, 0.0000],
        [0.0176, 0.2689, 0.0215, 0.0089, 0.6812, 0.0019, 0.0000, 0.0000],
        [0.1691, 0.4066, 0.0438, 0.0416, 0.1048, 0.2012, 0.0329, 0.0000],
        [0.0210, 0.0843, 0.0555, 0.2297, 0.0573, 0.0709, 0.2423, 0.2391]],
       grad_fn=&lt;SelectBackward0&gt;)</code></pre>
</div>
</div>
</section>
</section>
<section id="notes" class="level2">
<h2 class="anchored" data-anchor-id="notes">Notes:</h2>
<ul>
<li>Attention is a <strong>communication mechanism</strong>. Can be seen as nodes in a directed graph looking at each other and aggregating information with a weighted sum from all nodes that point to them, with data-dependent weights.</li>
<li>There is no notion of space. Attention simply acts over a set of vectors. This is why we need to positionally encode tokens.</li>
<li>Each example across batch dimension is of course processed completely independently and never “talk” to each other</li>
<li>In an “encoder” attention block just delete the single line that does masking with <code>tril</code>, allowing all tokens to communicate. This block here is called a “decoder” attention block because it has triangular masking, and is usually used in autoregressive settings, like language modeling.</li>
<li>“self-attention” just means that the keys and values are produced from the same source as queries. In “cross-attention”, the queries still get produced from x, but the keys and values come from some other, external source (e.g.&nbsp;an encoder module)</li>
<li>“Scaled” attention additionally divides <code>wei</code> by 1/sqrt(head_size). This makes it so when input Q,K are unit variance, wei will be unit variance too and Softmax will stay diffuse and not saturate too much. Illustration below’’</li>
</ul>
<div id="cell-42" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:47.598043Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:47.592161Z&quot;}" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># head_size is the dimension of "latent space"</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> torch.randn(B, T, head_size)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> torch.randn(B, T, head_size)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> head_size <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-43" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:48.557897Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:48.550456Z&quot;}" data-outputid="0c5b9cd0-af8a-4564-fbad-41d844e54822" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>k.var()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>tensor(1.0449)</code></pre>
</div>
</div>
<div id="cell-44" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:49.009300Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:49.002554Z&quot;}" data-outputid="3541ca1a-7447-4ef7-835e-81824aebc1b5" data-execution_count="29">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>q.var()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>tensor(1.0700)</code></pre>
</div>
</div>
<div id="cell-45" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:49.482165Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:49.473075Z&quot;}" data-outputid="a687a222-5a2c-4cdb-c1bf-17cd05b45b69" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>wei.var()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>tensor(1.0918)</code></pre>
</div>
</div>
<div id="cell-46" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:50.125578Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:50.119668Z&quot;}" data-outputid="f07da2f1-10bb-4a7a-bcaa-578587977d00" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>]), dim<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>tensor([0.1925, 0.1426, 0.2351, 0.1426, 0.2872])</code></pre>
</div>
</div>
<div id="cell-47" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:50.774492Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:50.768770Z&quot;}" data-outputid="5d8b910a-6192-44ba-ebb2-497d88e0b629" data-execution_count="32">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>]) <span class="op">*</span> <span class="dv">8</span>, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># gets too peaky, converges to one-hot</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>tensor([0.0326, 0.0030, 0.1615, 0.0030, 0.8000])</code></pre>
</div>
</div>
<div id="cell-48" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T10:04:51.425350Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T10:04:51.416960Z&quot;}" data-outputid="929ceb78-a639-41d6-aac7-12997b5c93f0" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LayerNorm1d:  <span class="co"># (used to be BatchNorm1d)</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim, eps<span class="op">=</span><span class="fl">1e-5</span>, momentum<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> torch.ones(dim)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> torch.zeros(dim)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate the forward pass</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>        xmean <span class="op">=</span> x.mean(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)  <span class="co"># batch mean</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        xvar <span class="op">=</span> x.var(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)  <span class="co"># batch variance</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>        xhat <span class="op">=</span> (x <span class="op">-</span> xmean) <span class="op">/</span> torch.sqrt(xvar <span class="op">+</span> <span class="va">self</span>.eps)  <span class="co"># normalize to unit variance</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.out <span class="op">=</span> <span class="va">self</span>.gamma <span class="op">*</span> xhat <span class="op">+</span> <span class="va">self</span>.beta</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.out</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parameters(<span class="va">self</span>):</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="va">self</span>.gamma, <span class="va">self</span>.beta]</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>module <span class="op">=</span> LayerNorm1d(<span class="dv">100</span>)</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a><span class="co"># batch_norm_1d = nn.BatchNorm1d(100)</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a><span class="co"># x_normalized_torch = batch_norm_1d(x)</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">100</span>)  <span class="co"># batch size 32 of 100-dimensional vectors</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>x_normalized <span class="op">=</span> module(x)</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>x_normalized.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>torch.Size([32, 100])</code></pre>
</div>
</div>
<div id="cell-50" class="cell" data-outputid="7720fa58-0478-4e8a-86a7-502d4cce9443" data-execution_count="34">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>x[:, <span class="dv">0</span>].mean(), x[:, <span class="dv">0</span>].std()  <span class="co"># mean,std of one feature across all batch inputs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>(tensor(0.1392), tensor(0.8899))</code></pre>
</div>
</div>
<div id="cell-51" class="cell" data-outputid="6368ece0-600e-417d-8a91-7c1e5d750ba8" data-execution_count="35">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>x[<span class="dv">0</span>, :].mean(), x[<span class="dv">0</span>, :].std()  <span class="co"># mean,std of a single input from the batch, of its features</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>(tensor(0.0409), tensor(1.0476))</code></pre>
</div>
</div>
<div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># French to English translation example:</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co"># &lt;--------- ENCODE ------------------&gt;&lt;--------------- DECODE -----------------&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co"># les réseaux de neurones sont géniaux! &lt;START&gt; neural networks are awesome!&lt;</span><span class="re">END</span><span class="co">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="full-finished-code-for-reference" class="level3">
<h3 class="anchored" data-anchor-id="full-finished-code-for-reference">Full finished code, for reference</h3>
<p>You may want to refer directly to the Karpathy’s <a href="https://github.com/karpathy/ng-video-lecture">git repo</a> or use <a href="https://github.com/karpathy/nanoGPT">NanoGPT</a> instead though.</p>
<div id="cell-54" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T12:38:44.597151Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T12:32:10.934438Z&quot;}" data-outputid="961304cd-e379-40d4-dd56-8de0b91d2861" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="co"># hyperparameters</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1024</span> <span class="co"># 16  # how many independent sequences will we process in parallel?</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>block_size <span class="op">=</span> <span class="dv">128</span> <span class="co"># 32  # what is the maximum context length for predictions?</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>max_iters <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>eval_interval <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>learning_rate <span class="op">=</span> <span class="fl">1e-3</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>eval_iters <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>n_embd <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>n_head <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>n_layer <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>dropout <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a><span class="co"># wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> Path(<span class="st">'~'</span>).expanduser() <span class="op">/</span> <span class="ss">f'.cache/input.txt'</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> save_path.exists():</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>wget https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>karpathy<span class="op">/</span>char<span class="op">-</span>rnn<span class="op">/</span>master<span class="op">/</span>data<span class="op">/</span>tinyshakespeare<span class="op">/</span><span class="bu">input</span>.txt <span class="op">-</span>O {save_path}</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a><span class="co"># here are all the unique characters that occur in this text</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="co"># create a mapping from characters to integers</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>stoi <span class="op">=</span> {ch: i <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars)}</span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>itos <span class="op">=</span> {i: ch <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars)}</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s]  <span class="co"># encoder: take a string, output a list of integers</span></span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l])  <span class="co"># decoder: take a list of integers, output a string</span></span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Train and test splits</span></span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span> <span class="op">*</span> <span class="bu">len</span>(data))  <span class="co"># first 90% will be train, rest val</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>val_data <span class="op">=</span> data[n:]</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a><span class="co"># data loading</span></span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_batch(split):</span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># generate a small batch of data of inputs x and targets y</span></span>
<span id="cb65-46"><a href="#cb65-46" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb65-47"><a href="#cb65-47" aria-hidden="true" tabindex="-1"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb65-48"><a href="#cb65-48" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> torch.stack([data[i:i <span class="op">+</span> block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb65-49"><a href="#cb65-49" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> torch.stack([data[i <span class="op">+</span> <span class="dv">1</span>:i <span class="op">+</span> block_size <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb65-50"><a href="#cb65-50" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> x.to(device), y.to(device)</span>
<span id="cb65-51"><a href="#cb65-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x, y</span>
<span id="cb65-52"><a href="#cb65-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-53"><a href="#cb65-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-54"><a href="#cb65-54" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb65-55"><a href="#cb65-55" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_loss():</span>
<span id="cb65-56"><a href="#cb65-56" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> {}</span>
<span id="cb65-57"><a href="#cb65-57" aria-hidden="true" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb65-58"><a href="#cb65-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> split <span class="kw">in</span> [<span class="st">'train'</span>, <span class="st">'val'</span>]:</span>
<span id="cb65-59"><a href="#cb65-59" aria-hidden="true" tabindex="-1"></a>        losses <span class="op">=</span> torch.zeros(eval_iters)</span>
<span id="cb65-60"><a href="#cb65-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(eval_iters):</span>
<span id="cb65-61"><a href="#cb65-61" aria-hidden="true" tabindex="-1"></a>            X, Y <span class="op">=</span> get_batch(split)</span>
<span id="cb65-62"><a href="#cb65-62" aria-hidden="true" tabindex="-1"></a>            logits, loss <span class="op">=</span> model(X, Y)</span>
<span id="cb65-63"><a href="#cb65-63" aria-hidden="true" tabindex="-1"></a>            losses[k] <span class="op">=</span> loss.item()</span>
<span id="cb65-64"><a href="#cb65-64" aria-hidden="true" tabindex="-1"></a>        out[split] <span class="op">=</span> losses.mean()</span>
<span id="cb65-65"><a href="#cb65-65" aria-hidden="true" tabindex="-1"></a>    model.train()</span>
<span id="cb65-66"><a href="#cb65-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb65-67"><a href="#cb65-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-68"><a href="#cb65-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-69"><a href="#cb65-69" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Head(nn.Module):</span>
<span id="cb65-70"><a href="#cb65-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" one head of self-attention</span></span>
<span id="cb65-71"><a href="#cb65-71" aria-hidden="true" tabindex="-1"></a><span class="co">        https://magazine.sebastianraschka.com/p/understanding-and-coding-self-attention</span></span>
<span id="cb65-72"><a href="#cb65-72" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb65-73"><a href="#cb65-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-74"><a href="#cb65-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, head_size):</span>
<span id="cb65-75"><a href="#cb65-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb65-76"><a href="#cb65-76" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.key <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb65-77"><a href="#cb65-77" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.query <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb65-78"><a href="#cb65-78" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb65-79"><a href="#cb65-79" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This limits us to the maximal context block_size</span></span>
<span id="cb65-80"><a href="#cb65-80" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.register_buffer(<span class="st">'tril'</span>, torch.tril(torch.ones(block_size, block_size)))</span>
<span id="cb65-81"><a href="#cb65-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-82"><a href="#cb65-82" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb65-83"><a href="#cb65-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-84"><a href="#cb65-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb65-85"><a href="#cb65-85" aria-hidden="true" tabindex="-1"></a>        B, T, C <span class="op">=</span> x.shape</span>
<span id="cb65-86"><a href="#cb65-86" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="va">self</span>.key(x)  <span class="co"># (B,T,C=n_embd) -&gt; (B,T,C=head_size)</span></span>
<span id="cb65-87"><a href="#cb65-87" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> <span class="va">self</span>.query(x)  <span class="co"># (B,T,C=n_embd) -&gt; (B,T,C=head_size)</span></span>
<span id="cb65-88"><a href="#cb65-88" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute attention scores ("affinities")</span></span>
<span id="cb65-89"><a href="#cb65-89" aria-hidden="true" tabindex="-1"></a>        wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> C <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span>  <span class="co"># (B, T, C=head_size) @ (B, C=head_size), T) -&gt; (B, T, T)</span></span>
<span id="cb65-90"><a href="#cb65-90" aria-hidden="true" tabindex="-1"></a>        wei <span class="op">=</span> wei.masked_fill(<span class="va">self</span>.tril[:T, :T] <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))  <span class="co"># (B, T, T)</span></span>
<span id="cb65-91"><a href="#cb65-91" aria-hidden="true" tabindex="-1"></a>        wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># (B, T, T)</span></span>
<span id="cb65-92"><a href="#cb65-92" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The drop out is over full matrix, alternatively it would be better to just drop on mask, this is biased</span></span>
<span id="cb65-93"><a href="#cb65-93" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Also it seems maybe conceptually we should just do symmetric dropout</span></span>
<span id="cb65-94"><a href="#cb65-94" aria-hidden="true" tabindex="-1"></a>        wei <span class="op">=</span> <span class="va">self</span>.dropout(wei)</span>
<span id="cb65-95"><a href="#cb65-95" aria-hidden="true" tabindex="-1"></a>        <span class="co"># perform the weighted aggregation of the values</span></span>
<span id="cb65-96"><a href="#cb65-96" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="va">self</span>.value(x)  <span class="co"># (B,T,C=head_size)</span></span>
<span id="cb65-97"><a href="#cb65-97" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The matrix multiplication is batched and applied on last two dimensions!</span></span>
<span id="cb65-98"><a href="#cb65-98" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> wei <span class="op">@</span> v  <span class="co"># (B, T, T) @ (B, T, C=head_size) -&gt; (B, T, C=head_size)</span></span>
<span id="cb65-99"><a href="#cb65-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> out</span>
<span id="cb65-100"><a href="#cb65-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-101"><a href="#cb65-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-102"><a href="#cb65-102" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MultiHeadAttention(nn.Module):</span>
<span id="cb65-103"><a href="#cb65-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" multiple heads of self-attention in parallel """</span></span>
<span id="cb65-104"><a href="#cb65-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-105"><a href="#cb65-105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_heads, head_size):</span>
<span id="cb65-106"><a href="#cb65-106" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb65-107"><a href="#cb65-107" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.heads <span class="op">=</span> nn.ModuleList([Head(head_size) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_heads)])</span>
<span id="cb65-108"><a href="#cb65-108" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Projection back to residual pathway, align the basis</span></span>
<span id="cb65-109"><a href="#cb65-109" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.proj <span class="op">=</span> nn.Linear(n_embd, n_embd)</span>
<span id="cb65-110"><a href="#cb65-110" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb65-111"><a href="#cb65-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-112"><a href="#cb65-112" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb65-113"><a href="#cb65-113" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> torch.cat([h(x) <span class="cf">for</span> h <span class="kw">in</span> <span class="va">self</span>.heads], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb65-114"><a href="#cb65-114" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.proj(out))</span>
<span id="cb65-115"><a href="#cb65-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> out</span>
<span id="cb65-116"><a href="#cb65-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-117"><a href="#cb65-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-118"><a href="#cb65-118" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FeedFoward(nn.Module):</span>
<span id="cb65-119"><a href="#cb65-119" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" a simple linear layer followed by a non-linearity """</span></span>
<span id="cb65-120"><a href="#cb65-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-121"><a href="#cb65-121" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd):</span>
<span id="cb65-122"><a href="#cb65-122" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb65-123"><a href="#cb65-123" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb65-124"><a href="#cb65-124" aria-hidden="true" tabindex="-1"></a>            nn.Linear(n_embd, <span class="dv">4</span> <span class="op">*</span> n_embd),</span>
<span id="cb65-125"><a href="#cb65-125" aria-hidden="true" tabindex="-1"></a>            nn.ReLU(),</span>
<span id="cb65-126"><a href="#cb65-126" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">4</span> <span class="op">*</span> n_embd, n_embd), <span class="co"># Projection back to residual pathway</span></span>
<span id="cb65-127"><a href="#cb65-127" aria-hidden="true" tabindex="-1"></a>            nn.Dropout(dropout),</span>
<span id="cb65-128"><a href="#cb65-128" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb65-129"><a href="#cb65-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-130"><a href="#cb65-130" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb65-131"><a href="#cb65-131" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.net(x)</span>
<span id="cb65-132"><a href="#cb65-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-133"><a href="#cb65-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-134"><a href="#cb65-134" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Block(nn.Module):</span>
<span id="cb65-135"><a href="#cb65-135" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Transformer block: communication followed by computation """</span></span>
<span id="cb65-136"><a href="#cb65-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-137"><a href="#cb65-137" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd: <span class="bu">int</span>, n_head: <span class="bu">int</span>):</span>
<span id="cb65-138"><a href="#cb65-138" aria-hidden="true" tabindex="-1"></a>        <span class="co"># n_embd: embedding dimension, n_head: the number of heads we'd like</span></span>
<span id="cb65-139"><a href="#cb65-139" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb65-140"><a href="#cb65-140" aria-hidden="true" tabindex="-1"></a>        <span class="co"># To guarantee that final concatenated embedding is of size n_embd </span></span>
<span id="cb65-141"><a href="#cb65-141" aria-hidden="true" tabindex="-1"></a>        head_size <span class="op">=</span> n_embd <span class="op">//</span> n_head</span>
<span id="cb65-142"><a href="#cb65-142" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sa <span class="op">=</span> MultiHeadAttention(n_head, head_size)</span>
<span id="cb65-143"><a href="#cb65-143" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ffwd <span class="op">=</span> FeedFoward(n_embd)</span>
<span id="cb65-144"><a href="#cb65-144" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ln1 <span class="op">=</span> nn.LayerNorm(n_embd)</span>
<span id="cb65-145"><a href="#cb65-145" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ln2 <span class="op">=</span> nn.LayerNorm(n_embd)</span>
<span id="cb65-146"><a href="#cb65-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-147"><a href="#cb65-147" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb65-148"><a href="#cb65-148" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Skip connections added to improve the flow of gradient</span></span>
<span id="cb65-149"><a href="#cb65-149" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Need to project back to residual pathway in sa and ffwd to "align bases" </span></span>
<span id="cb65-150"><a href="#cb65-150" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb65-151"><a href="#cb65-151" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Modern way is do to layer norm before and not after, in original paper it was done after, we do before!</span></span>
<span id="cb65-152"><a href="#cb65-152" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.sa(<span class="va">self</span>.ln1(x))</span>
<span id="cb65-153"><a href="#cb65-153" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.ffwd(<span class="va">self</span>.ln2(x))</span>
<span id="cb65-154"><a href="#cb65-154" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb65-155"><a href="#cb65-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-156"><a href="#cb65-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-157"><a href="#cb65-157" aria-hidden="true" tabindex="-1"></a><span class="co"># Not so super simple and not bigram model anymore</span></span>
<span id="cb65-158"><a href="#cb65-158" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GPT2LanguageModel(nn.Module):</span>
<span id="cb65-159"><a href="#cb65-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-160"><a href="#cb65-160" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb65-161"><a href="#cb65-161" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb65-162"><a href="#cb65-162" aria-hidden="true" tabindex="-1"></a>        <span class="co"># each token is mapped to latent space of size n_embd</span></span>
<span id="cb65-163"><a href="#cb65-163" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, n_embd)</span>
<span id="cb65-164"><a href="#cb65-164" aria-hidden="true" tabindex="-1"></a>        <span class="co"># learnable position embedding for positions 0, ..., block_size - 1</span></span>
<span id="cb65-165"><a href="#cb65-165" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.position_embedding_table <span class="op">=</span> nn.Embedding(block_size, n_embd)</span>
<span id="cb65-166"><a href="#cb65-166" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Modern way of handling this is:</span></span>
<span id="cb65-167"><a href="#cb65-167" aria-hidden="true" tabindex="-1"></a>        <span class="co"># https://machinelearningmastery.com/a-gentle-introduction-to-positional-encoding-in-transformer-models-part-1/</span></span>
<span id="cb65-168"><a href="#cb65-168" aria-hidden="true" tabindex="-1"></a>        <span class="co"># https://afterhoursresearch.hashnode.dev/rope-rotary-positional-embedding</span></span>
<span id="cb65-169"><a href="#cb65-169" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.blocks <span class="op">=</span> nn.Sequential(<span class="op">*</span>[Block(n_embd, n_head<span class="op">=</span>n_head) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_layer)])</span>
<span id="cb65-170"><a href="#cb65-170" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ln_f <span class="op">=</span> nn.LayerNorm(n_embd)  <span class="co"># final layer norm</span></span>
<span id="cb65-171"><a href="#cb65-171" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lm_head <span class="op">=</span> nn.Linear(n_embd, vocab_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb65-172"><a href="#cb65-172" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb65-173"><a href="#cb65-173" aria-hidden="true" tabindex="-1"></a>        <span class="co"># init all weights, and apply a special scaled init to the residual projections, per GPT-2 paper</span></span>
<span id="cb65-174"><a href="#cb65-174" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">apply</span>(<span class="va">self</span>._init_weights)</span>
<span id="cb65-175"><a href="#cb65-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pn, p <span class="kw">in</span> <span class="va">self</span>.named_parameters():</span>
<span id="cb65-176"><a href="#cb65-176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pn.endswith(<span class="st">'proj.weight'</span>):</span>
<span id="cb65-177"><a href="#cb65-177" aria-hidden="true" tabindex="-1"></a>                torch.nn.init.normal_(p, mean<span class="op">=</span><span class="fl">0.0</span>, std<span class="op">=</span><span class="fl">0.02</span><span class="op">/</span>math.sqrt(<span class="dv">2</span> <span class="op">*</span> n_layer))</span>
<span id="cb65-178"><a href="#cb65-178" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb65-179"><a href="#cb65-179" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _init_weights(<span class="va">self</span>, module):</span>
<span id="cb65-180"><a href="#cb65-180" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Not really needed but with this in the convergence is faster</span></span>
<span id="cb65-181"><a href="#cb65-181" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(module, nn.Linear):</span>
<span id="cb65-182"><a href="#cb65-182" aria-hidden="true" tabindex="-1"></a>            torch.nn.init.normal_(module.weight, mean<span class="op">=</span><span class="fl">0.0</span>, std<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb65-183"><a href="#cb65-183" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> module.bias <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb65-184"><a href="#cb65-184" aria-hidden="true" tabindex="-1"></a>                torch.nn.init.zeros_(module.bias)</span>
<span id="cb65-185"><a href="#cb65-185" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(module, nn.Embedding):</span>
<span id="cb65-186"><a href="#cb65-186" aria-hidden="true" tabindex="-1"></a>            torch.nn.init.normal_(module.weight, mean<span class="op">=</span><span class="fl">0.0</span>, std<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb65-187"><a href="#cb65-187" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(module, nn.LayerNorm):</span>
<span id="cb65-188"><a href="#cb65-188" aria-hidden="true" tabindex="-1"></a>            torch.nn.init.zeros_(module.bias)</span>
<span id="cb65-189"><a href="#cb65-189" aria-hidden="true" tabindex="-1"></a>            torch.nn.init.ones_(module.weight)</span>
<span id="cb65-190"><a href="#cb65-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-191"><a href="#cb65-191" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx, targets<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb65-192"><a href="#cb65-192" aria-hidden="true" tabindex="-1"></a>        B, T <span class="op">=</span> idx.shape</span>
<span id="cb65-193"><a href="#cb65-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-194"><a href="#cb65-194" aria-hidden="true" tabindex="-1"></a>        <span class="co"># idx and targets are both (B,T) tensor of integers</span></span>
<span id="cb65-195"><a href="#cb65-195" aria-hidden="true" tabindex="-1"></a>        tok_emb <span class="op">=</span> <span class="va">self</span>.token_embedding_table(idx)  <span class="co"># (B,T,C=n_embd)</span></span>
<span id="cb65-196"><a href="#cb65-196" aria-hidden="true" tabindex="-1"></a>        pos_emb <span class="op">=</span> <span class="va">self</span>.position_embedding_table(torch.arange(T, device<span class="op">=</span>device))  <span class="co"># (T,C=n_embd)</span></span>
<span id="cb65-197"><a href="#cb65-197" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> tok_emb <span class="op">+</span> pos_emb  <span class="co"># (B,T,C=n_embd)</span></span>
<span id="cb65-198"><a href="#cb65-198" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.blocks(x)  <span class="co"># (B,T,C=n_embd)</span></span>
<span id="cb65-199"><a href="#cb65-199" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Modern way is do to layer norm before and not after, in original paper it was done after, we do before!</span></span>
<span id="cb65-200"><a href="#cb65-200" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.ln_f(x)  <span class="co"># (B,T,C=n_embd)</span></span>
<span id="cb65-201"><a href="#cb65-201" aria-hidden="true" tabindex="-1"></a>        logits <span class="op">=</span> <span class="va">self</span>.lm_head(x)  <span class="co"># (B,T,vocab_size)</span></span>
<span id="cb65-202"><a href="#cb65-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-203"><a href="#cb65-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb65-204"><a href="#cb65-204" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> <span class="va">None</span></span>
<span id="cb65-205"><a href="#cb65-205" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb65-206"><a href="#cb65-206" aria-hidden="true" tabindex="-1"></a>            B, T, C <span class="op">=</span> logits.shape</span>
<span id="cb65-207"><a href="#cb65-207" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> logits.view(B <span class="op">*</span> T, C)</span>
<span id="cb65-208"><a href="#cb65-208" aria-hidden="true" tabindex="-1"></a>            targets <span class="op">=</span> targets.view(B <span class="op">*</span> T)</span>
<span id="cb65-209"><a href="#cb65-209" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb65-210"><a href="#cb65-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-211"><a href="#cb65-211" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logits, loss</span>
<span id="cb65-212"><a href="#cb65-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-213"><a href="#cb65-213" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx, max_new_tokens):</span>
<span id="cb65-214"><a href="#cb65-214" aria-hidden="true" tabindex="-1"></a>        <span class="co"># idx is (B, T) array of indices in the current context</span></span>
<span id="cb65-215"><a href="#cb65-215" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb65-216"><a href="#cb65-216" aria-hidden="true" tabindex="-1"></a>            <span class="co"># crop idx to the last block_size tokens, otherwise things will explode</span></span>
<span id="cb65-217"><a href="#cb65-217" aria-hidden="true" tabindex="-1"></a>            idx_cond <span class="op">=</span> idx[:, <span class="op">-</span>block_size:]</span>
<span id="cb65-218"><a href="#cb65-218" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get the predictions</span></span>
<span id="cb65-219"><a href="#cb65-219" aria-hidden="true" tabindex="-1"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx_cond)</span>
<span id="cb65-220"><a href="#cb65-220" aria-hidden="true" tabindex="-1"></a>            <span class="co"># focus only on the last time step</span></span>
<span id="cb65-221"><a href="#cb65-221" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :]  <span class="co"># (B, T, C=vocab_size) becomes (B, C=vocab_size)</span></span>
<span id="cb65-222"><a href="#cb65-222" aria-hidden="true" tabindex="-1"></a>            <span class="co"># apply softmax to get probabilities</span></span>
<span id="cb65-223"><a href="#cb65-223" aria-hidden="true" tabindex="-1"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># (B, C=vocab_size)</span></span>
<span id="cb65-224"><a href="#cb65-224" aria-hidden="true" tabindex="-1"></a>            <span class="co"># sample from the multinomial distribution</span></span>
<span id="cb65-225"><a href="#cb65-225" aria-hidden="true" tabindex="-1"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (B, 1)</span></span>
<span id="cb65-226"><a href="#cb65-226" aria-hidden="true" tabindex="-1"></a>            <span class="co"># append sampled index to the running sequence</span></span>
<span id="cb65-227"><a href="#cb65-227" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (B, T+1)</span></span>
<span id="cb65-228"><a href="#cb65-228" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idx</span>
<span id="cb65-229"><a href="#cb65-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-230"><a href="#cb65-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-231"><a href="#cb65-231" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPT2LanguageModel()</span>
<span id="cb65-232"><a href="#cb65-232" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> model.to(device)</span>
<span id="cb65-233"><a href="#cb65-233" aria-hidden="true" tabindex="-1"></a><span class="co"># print the number of parameters in the model</span></span>
<span id="cb65-234"><a href="#cb65-234" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sum</span>(p.numel() <span class="cf">for</span> p <span class="kw">in</span> m.parameters()) <span class="op">/</span> <span class="fl">1e6</span>, <span class="st">'M parameters'</span>)</span>
<span id="cb65-235"><a href="#cb65-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-236"><a href="#cb65-236" aria-hidden="true" tabindex="-1"></a><span class="co"># create a PyTorch optimizer</span></span>
<span id="cb65-237"><a href="#cb65-237" aria-hidden="true" tabindex="-1"></a><span class="co"># https://www.ruder.io/optimizing-gradient-descent/#adam</span></span>
<span id="cb65-238"><a href="#cb65-238" aria-hidden="true" tabindex="-1"></a><span class="co"># https://iclr-blogposts.github.io/2023/blog/2023/adamw/</span></span>
<span id="cb65-239"><a href="#cb65-239" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.AdamW(model.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb65-240"><a href="#cb65-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-241"><a href="#cb65-241" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(max_iters):</span>
<span id="cb65-242"><a href="#cb65-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-243"><a href="#cb65-243" aria-hidden="true" tabindex="-1"></a>    <span class="co"># every once in a while evaluate the loss on train and val sets</span></span>
<span id="cb65-244"><a href="#cb65-244" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">iter</span> <span class="op">%</span> eval_interval <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="bu">iter</span> <span class="op">==</span> max_iters <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb65-245"><a href="#cb65-245" aria-hidden="true" tabindex="-1"></a>        losses <span class="op">=</span> estimate_loss()</span>
<span id="cb65-246"><a href="#cb65-246" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"step </span><span class="sc">{</span><span class="bu">iter</span><span class="sc">}</span><span class="ss">: train loss </span><span class="sc">{</span>losses[<span class="st">'train'</span>]<span class="sc">:.4f}</span><span class="ss">, val loss </span><span class="sc">{</span>losses[<span class="st">'val'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb65-247"><a href="#cb65-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-248"><a href="#cb65-248" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sample a batch of data</span></span>
<span id="cb65-249"><a href="#cb65-249" aria-hidden="true" tabindex="-1"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb65-250"><a href="#cb65-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-251"><a href="#cb65-251" aria-hidden="true" tabindex="-1"></a>    <span class="co"># evaluate the loss</span></span>
<span id="cb65-252"><a href="#cb65-252" aria-hidden="true" tabindex="-1"></a>    logits, loss <span class="op">=</span> model(xb, yb)</span>
<span id="cb65-253"><a href="#cb65-253" aria-hidden="true" tabindex="-1"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb65-254"><a href="#cb65-254" aria-hidden="true" tabindex="-1"></a>    loss.backward()</span>
<span id="cb65-255"><a href="#cb65-255" aria-hidden="true" tabindex="-1"></a>    optimizer.step()</span>
<span id="cb65-256"><a href="#cb65-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-257"><a href="#cb65-257" aria-hidden="true" tabindex="-1"></a><span class="co"># generate from the model</span></span>
<span id="cb65-258"><a href="#cb65-258" aria-hidden="true" tabindex="-1"></a>context <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>, device<span class="op">=</span>device)</span>
<span id="cb65-259"><a href="#cb65-259" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode(m.generate(context, max_new_tokens<span class="op">=</span><span class="dv">2000</span>)[<span class="dv">0</span>].tolist()))</span>
<span id="cb65-260"><a href="#cb65-260" aria-hidden="true" tabindex="-1"></a><span class="co"># Temperature motivation https://en.wikipedia.org/wiki/LogSumExp</span></span>
<span id="cb65-261"><a href="#cb65-261" aria-hidden="true" tabindex="-1"></a><span class="co"># What happens when you divide logits by posite Temp and then do softmax</span></span>
<span id="cb65-262"><a href="#cb65-262" aria-hidden="true" tabindex="-1"></a><span class="co"># Temp close to 0 is max in limit, one hot, Temp &gt;&gt; 1 in limit random</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>0.215808 M parameters
step 0: train loss 4.1890, val loss 4.1885
step 100: train loss 2.5203, val loss 2.5128
step 200: train loss 2.2087, val loss 2.2280
step 300: train loss 1.9885, val loss 2.0614
step 400: train loss 1.7996, val loss 1.9230
step 500: train loss 1.7208, val loss 1.8648
step 600: train loss 1.6610, val loss 1.8272
step 700: train loss 1.6218, val loss 1.7936
step 800: train loss 1.5859, val loss 1.7645
step 900: train loss 1.5593, val loss 1.7374
step 1000: train loss 1.5727, val loss 1.7391
step 1100: train loss 1.5257, val loss 1.7019
step 1200: train loss 1.5101, val loss 1.6936
step 1300: train loss 1.5033, val loss 1.6867
step 1400: train loss 1.4825, val loss 1.6667
step 1500: train loss 1.4743, val loss 1.6577
step 1600: train loss 1.4717, val loss 1.6572
step 1700: train loss 1.4584, val loss 1.6505
step 1800: train loss 1.4466, val loss 1.6353
step 1900: train loss 1.4423, val loss 1.6301
step 2000: train loss 1.4483, val loss 1.6326
step 2100: train loss 1.4322, val loss 1.6291
step 2200: train loss 1.4267, val loss 1.6201
step 2300: train loss 1.4237, val loss 1.6142
step 2400: train loss 1.4157, val loss 1.6069
step 2500: train loss 1.4104, val loss 1.6050
step 2600: train loss 1.4105, val loss 1.6065
step 2700: train loss 1.4058, val loss 1.6060
step 2800: train loss 1.4023, val loss 1.5983
step 2900: train loss 1.3992, val loss 1.5967
step 3000: train loss 1.3964, val loss 1.5929
step 3100: train loss 1.3934, val loss 1.5959
step 3200: train loss 1.3905, val loss 1.5892
step 3300: train loss 1.3861, val loss 1.5817
step 3400: train loss 1.3873, val loss 1.5865
step 3500: train loss 1.3850, val loss 1.5846
step 3600: train loss 1.3816, val loss 1.5820
step 3700: train loss 1.3786, val loss 1.5816
step 3800: train loss 1.3778, val loss 1.5762
step 3900: train loss 1.3747, val loss 1.5735
step 4000: train loss 1.3722, val loss 1.5791
step 4100: train loss 1.3727, val loss 1.5765
step 4200: train loss 1.3725, val loss 1.5795
step 4300: train loss 1.3736, val loss 1.5785
step 4400: train loss 1.3675, val loss 1.5717
step 4500: train loss 1.3649, val loss 1.5684
step 4600: train loss 1.3663, val loss 1.5669
step 4700: train loss 1.3611, val loss 1.5657
step 4800: train loss 1.3614, val loss 1.5636
step 4900: train loss 1.3591, val loss 1.5697
step 5000: train loss 1.3640, val loss 1.5737
step 5100: train loss 1.8337, val loss 1.9548
step 5200: train loss 1.3989, val loss 1.6005
step 5300: train loss 1.3727, val loss 1.5784
step 5400: train loss 1.3656, val loss 1.5752
step 5500: train loss 1.3609, val loss 1.5700
step 5600: train loss 1.3588, val loss 1.5663
step 5700: train loss 1.3558, val loss 1.5678
step 5800: train loss 1.3536, val loss 1.5654
step 5900: train loss 1.3526, val loss 1.5655
step 6000: train loss 1.3500, val loss 1.5611
step 6100: train loss 1.3543, val loss 1.5676
step 6200: train loss 1.3485, val loss 1.5605
step 6300: train loss 1.3472, val loss 1.5632
step 6400: train loss 1.3463, val loss 1.5652
step 6500: train loss 1.3445, val loss 1.5602
step 6600: train loss 1.3436, val loss 1.5604
step 6700: train loss 1.3427, val loss 1.5672
step 6800: train loss 1.3439, val loss 1.5627
step 6900: train loss 1.3393, val loss 1.5595
step 7000: train loss 1.3419, val loss 1.5651
step 7100: train loss 1.3409, val loss 1.5611
step 7200: train loss 1.3427, val loss 1.5649
step 7300: train loss 1.3393, val loss 1.5593
step 7400: train loss 1.3360, val loss 1.5573
step 7500: train loss 1.3405, val loss 1.5673
step 7600: train loss 1.3387, val loss 1.5630
step 7700: train loss 1.3365, val loss 1.5624
step 7800: train loss 1.3336, val loss 1.5640
step 7900: train loss 1.3351, val loss 1.5637
step 8000: train loss 1.3350, val loss 1.5658
step 8100: train loss 1.3320, val loss 1.5566
step 8200: train loss 1.3315, val loss 1.5572
step 8300: train loss 1.3321, val loss 1.5573
step 8400: train loss 1.3321, val loss 1.5650
step 8500: train loss 1.3326, val loss 1.5600
step 8600: train loss 1.3325, val loss 1.5667
step 8700: train loss 1.3300, val loss 1.5573
step 8800: train loss 1.3289, val loss 1.5581
step 8900: train loss 1.3289, val loss 1.5621
step 9000: train loss 1.3276, val loss 1.5536
step 9100: train loss 1.3263, val loss 1.5544
step 9200: train loss 1.3284, val loss 1.5636
step 9300: train loss 1.3270, val loss 1.5552
step 9400: train loss 1.3262, val loss 1.5569
step 9500: train loss 1.3264, val loss 1.5593
step 9600: train loss 1.3250, val loss 1.5538
step 9700: train loss 1.3251, val loss 1.5588
step 9800: train loss 1.3245, val loss 1.5568
step 9900: train loss 1.3228, val loss 1.5628
step 9999: train loss 1.3235, val loss 1.5614


DUKE Venery to tiege's nague will in him.
Go, lamen, were no my none, I'll faith? Lower.

NORTHUMBY:
I am proper: and thy rain for chaired
Befice, gone
Hear years; yet sail a inferous to orguate.

JULIET:
Here your daminate to the people, and,
They have. Marry begind-because you
Sweing a wealth. Poor Clareretian seed:
But, care widownest us?

Menen, no surpose him: why, hither, venteren, he is it
sweet a fall furthy this own, therefore I not in
it.

PRINCE ERKICHARD:
A least thee loved a kise of licke worth
Begain and at so sceedd the weakning sight.

ROMEO.

Rush on vailships the and the eny-I swir,
For awil truthfus, both unflowers there to be would
sussles than at the goodlor. Al tell; besimes
To his bearet win a both toes,
And love to soldie the deckoodly for a
whence have Stay 'gawd very.
Fathely we should go break up.'

Most in his friend all.

CORIOLANUS:
Thou play there must it wilt not
To foot twell more my eear of Bolingbroke,
An all with suilench' thou may two Preasage!

Server I will so happy of our bardled
Conter mine strik's too the good rogues,
And kear pout of my heart yea bed.
That's is all, for in the bross them sead?
Did darers o stands yours, are I be for you;
Sheppale knows much ding sighs made a should bear
To shall proft-my gantlen.

Fesorow, if you be a conseged a hour, bastand I
Have this sheople, nor Hanry must might of my sovet?

GLOUCESTER:
What, mercy on'tis treather it was a fortnes?
Alp you my royal, sin, in say.
Withing al toffull my virguide could, as't.

KING RICHARD:
Bring gracious loves sothers, throate i' the
That
Would parinage to secrif' the bloody sigh, and there,
Who stand, unimation their aven ever pleasure
Friend-compet As he bed: you was fold from
And that fair or was him, to to preasures,
To pranset thy love. But, the loators' tear,
Were not and that tell the depop, not cheel?
arklains overy clorge tack in mail buill
With ward her brother'd a dear ClifLo,
You shall perincation, and you are at noble.

BAHORSON:
Servant it</code></pre>
</div>
</div>
</section>
<section id="draw-the-model-graph" class="level3">
<h3 class="anchored" data-anchor-id="draw-the-model-graph">Draw the model graph</h3>
<div id="cell-56" class="cell" data-executetime="{&quot;end_time&quot;:&quot;2024-04-18T13:45:18.731302Z&quot;,&quot;start_time&quot;:&quot;2024-04-18T13:45:16.626372Z&quot;}" data-execution_count="37">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/szagoruyko/pytorchviz</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co"># https://github.com/mert-kurttutan/torchview nicer graph</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchview <span class="im">import</span> draw_graph</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchlens <span class="im">as</span> tl</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co"># device='meta' -&gt; no memory is consumed for visualization</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xb.shape)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(yb.shape)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>model_graph <span class="op">=</span> draw_graph(model, input_data<span class="op">=</span>(xb, yb), device<span class="op">=</span><span class="st">'cuda'</span>)</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>model_graph.visual_graph</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>save <span class="op">=</span> <span class="va">True</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> Path(<span class="st">'~/.cache'</span>).expanduser()</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> save:</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>    torch.save(model.state_dict(), save_path <span class="op">/</span> <span class="st">'gpt2.pt'</span>)</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>    torch.save(optimizer.state_dict(), save_path <span class="op">/</span> <span class="st">'gpt2_opt.pt'</span>)</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="co"># model_history = tl.log_forward_pass(model, (xb, yb)</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a><span class="co">#                                      , layers_to_save='all', vis_opt='unrolled')</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a><span class="co"># print(model_history)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([1024, 128])
torch.Size([1024, 128])</code></pre>
</div>
</div>
<div id="cell-57" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># generate from the model</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Put to evaluation mode to set Dropout to evaluation mode</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>context <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>, device<span class="op">=</span>device)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode(model.generate(context, max_new_tokens<span class="op">=</span><span class="dv">2000</span>)[<span class="dv">0</span>].tolist()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
LUCIO:
Nor attume to the whrewnty-shall not doubt good weak
The pluck all on thee on thy heart, much serping.

GLOUCESTER:
Come, he shall be hears that should speak of phyself
From humble and achery a heaver'd mirth,
Contice.

KING RICHARD IIV:
Intil you have 'tis their head.

JOHN OF GAUNT:
They have beart a praise and vals to see yourself;
And not to depose it, and, sweet before
The gown of the sentigal of house,
Might he shall, by where are to be yet?

First Keeper:
What is envy of our dead, for England.

Second Murderess:
A kind; he will may be conclifed thee.

Clown:
Them thrust I cannot be say, if I came; away.
Why, sir, when then stufff that's life
Reportence wings, were if he seek!

JULIET:
This pass good time love more.

Second Servant:
O, he fited upon the voice,
And which a bed-will place, by the hinnguns
hite such rumation.

Second Gentleman:
They have
But ear to such our burths is friend could rewith.

HORTENSIO:
One shall say, think yet shall thy least from my good grace!

ESCALUS:
I would go then, stand good as as to so.

DUKE VINCENTIO:
And was thry face: I'll not condry.
What proudy the great of the port, affter,
And I cired so thee soul, that farewell have;
Parged him me with quite her the accussed,
And with a montages. Thy spacress her peace
Of to their moother friends, and lucks: there,
When we dare any with English uncle Mighcaster!
What's remosted on unterty father whom
the pregned neck it that is be to be
I a joy of crown, of a fear he imposited.

PERDITA:
Foul came to Hacking so dispubble valm,
Than away?

BUCKINGHAM:
Ay, lot leave?

JULIET:
Here ever Rome, follow which even lives a sickning
Which of execut. Away they swift from you fame
And not thee, or in as a beding thee?

Second Citizen:
Here, he's sir; fooly lives' false will,
Strit, sir. Thou must to fe did death.

DUKE VINCENTIO:
I fear. Theu do, you, thou love--
Gentleman we, victory of my head did for all,
They shall call to the king noble Romeo.

Shore.

LUCIO:
You canst and a shall</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>